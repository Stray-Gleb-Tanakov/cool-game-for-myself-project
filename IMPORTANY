// Wait for the DOM to be fully loaded before running the game
document.addEventListener('DOMContentLoaded', function() {
    // ========== GAME SETUP ==========
    // Get canvas element and set up rendering context
    const canvas = document.getElementById('gameCanvas');
    
    // Check if canvas exists
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }
    
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions - these are the visible area
    canvas.width = 1200; 
    canvas.height = 900;
    
    // Game world dimensions - larger than visible area for scrolling
    const worldWidth = 7200; 
    const worldHeight = 4000;
    
    // ========== WEAPON PROPERTIES ==========
    const weaponProperties = {
        pistol: {
            damage: 10,
            maxAmmo: 12,
            reloadTime: 60,
            fireRate: 15,
            bulletSpeed: 15,
            bulletRange: 500,
            bounces: 3,
            color: '#ffff00'
        },
        shotgun: {
            damage: 5,
            maxAmmo: 2,
            reloadTime: 90,
            fireRate: 30,
            bulletSpeed: 12,
            bulletRange: 300,
            bounces: 1,
            pelletCount: 10,
            spreadAngle: Math.PI / 6,
            color: '#ff9900'
        },
        sniper: {
            damage: 25,
            maxAmmo: 5,
            reloadTime: 120,
            fireRate: 45,
            bulletSpeed: 25,
            bulletRange: 1000,
            bounces: 0,
            color: '#00ffff',
            canPassThroughWalls: true
        }
    };
    
    // ========== ENEMY TYPES ==========
    const enemyTypes = {
        basic: {
            health: 10,
            maxHealth: 10,
            speed: 0.7,
            size: 15,
            color: '#ff00ff',
            hasKnife: true,
            attackDamage: 10,
            attackRange: 30,
            detectionRange: 800
        },
        sniper: {
            health: 25,
            maxHealth: 25,
            speed: 0.5,
            size: 20,
            color: '#00ff00',
            hasKnife: false,
            attackDamage: 15,
            attackRange: 1000,
            detectionRange: 1200,
            fireRate: 90,
            canShootThroughWalls: false,
            bulletSpeed: 6
        },
        heavy: {
            health: 40,
            maxHealth: 40,
            speed: 0.4,
            size: 25,
            color: '#ff0000',
            hasKnife: true,
            attackDamage: 20,
            attackRange: 30,
            detectionRange: 600
        },
        shield: {
            health: 30,
            maxHealth: 30,
            speed: 0.5,
            size: 20,
            color: '#0099ff',
            hasKnife: true,
            attackDamage: 15,
            attackRange: 30,
            detectionRange: 800,
            hasShield: true,
            shieldHealth: 20,
            shieldMaxHealth: 20
        },
        suicide: {
            health: 15,
            maxHealth: 15,
            speed: 1.5,
            size: 15,
            color: '#ff9900',
            hasKnife: false,
            attackDamage: 50,
            attackRange: 40,
            detectionRange: 1000,
            explosionRadius: 100,
            explodesOnDeath: true
        },
        spawner: {
            health: 50,
            maxHealth: 50,
            speed: 0.3,
            size: 25,
            color: '#9933ff',
            hasKnife: false,
            attackDamage: 10,
            attackRange: 800,
            detectionRange: 1200,
            canSpawn: true,
            spawnCooldown: 180,
            spawnRadius: 150
        }
    };
    
    // ========== CAMERA SYSTEM ==========
    const camera = {
        x: 0,
        y: 0,
        width: canvas.width,
        height: canvas.height,
        followSpeed: 0.1,
        shakeIntensity: 0
    };
    
    // ========== PLAYER OBJECT ==========
    let player = {
        size: 15,
        speed: 3,
        angle: 0,
        health: 100,
        maxHealth: 100,
        isShooting: false,
        shootCooldown: 0,
        currentWeapon: 'pistol',
        pistolAmmo: 12,
        shotgunAmmo: 2,
        sniperAmmo: 5,
        isReloading: false,
        reloadTime: 0,
        pistolSemiAuto: true,
        isShotgunCocked: true,
        isSniperReady: true,
        isKicking: false,
        kickCooldown: 0,
        invulnerable: false,
        invulnerableTime: 0,
        isDead: false
    };
    
    // ========== GAME OBJECTS ==========
    let bullets = [];
    let enemies = [];
    let walls = [];
    let doors = [];
    let particles = [];
    let bloodSplatters = [];
    let floatingTexts = [];
    let exitPortal = null;
    let boss = null;
    let kills = 0;
    let combo = 0;
    let lastKillTime = 0;
    let score = 0;
    let levelComplete = false;
    let levelStartTime = Date.now();
    
    // ========== QUADTREE PATHFINDING ==========
    class QuadTreeNode {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.children = [];
            this.isLeaf = true;
            this.walkable = true;
            this.neighbors = [];
            this.id = `${x},${y},${width},${height}`;
        }
        
        subdivide() {
            if (this.width < 60 || this.height < 60) return;
            
            const halfWidth = this.width / 2;
            const halfHeight = this.height / 2;
            
            // Create four children
            this.children.push(new QuadTreeNode(this.x, this.y, halfWidth, halfHeight));
            this.children.push(new QuadTreeNode(this.x + halfWidth, this.y, halfWidth, halfHeight));
            this.children.push(new QuadTreeNode(this.x, this.y + halfHeight, halfWidth, halfHeight));
            this.children.push(new QuadTreeNode(this.x + halfWidth, this.y + halfHeight, halfWidth, halfHeight));
            
            this.isLeaf = false;
        }
        
        contains(x, y) {
            return x >= this.x && x < this.x + this.width &&
                   y >= this.y && y < this.y + this.height;
        }
        
        intersects(rect) {
            return !(rect.x + rect.width < this.x || 
                     rect.x > this.x + this.width ||
                     rect.y + rect.height < this.y || 
                     rect.y > this.y + this.height);
        }
    }
    
    class QuadTree {
        constructor(worldWidth, worldHeight) {
            this.root = new QuadTreeNode(0, 0, worldWidth, worldHeight);
            this.leafNodes = [];
            this.nodeMap = new Map();
        }
        
        buildTree(walls, doors) {
            this._subdivideRecursive(this.root, walls, doors);
            this._collectLeafNodes(this.root);
            this._buildNeighborGraph();
        }
        
        _subdivideRecursive(node, walls, doors) {
            // Check if node contains obstacles
            let hasObstacle = false;
            
            for (const wall of walls) {
                if (node.intersects(wall)) {
                    hasObstacle = true;
                    break;
                }
            }
            
            if (!hasObstacle) {
                for (const door of doors) {
                    if (!door.isBroken && node.intersects(door)) {
                        hasObstacle = true;
                        break;
                    }
                }
            }
            
            // If node has obstacles and is large enough, subdivide
            if (hasObstacle && node.width >= 60 && node.height >= 60) {
                node.subdivide();
                
                for (const child of node.children) {
                    this._subdivideRecursive(child, walls, doors);
                }
            } else {
                // Mark as walkable if no obstacles
                node.walkable = !hasObstacle;
            }
        }
        
        _collectLeafNodes(node) {
            if (node.isLeaf) {
                if (node.walkable) {
                    this.leafNodes.push(node);
                    this.nodeMap.set(node.id, node);
                }
            } else {
                for (const child of node.children) {
                    this._collectLeafNodes(child);
                }
            }
        }
        
        _buildNeighborGraph() {
            // For each leaf node, find adjacent leaf nodes
            for (const node of this.leafNodes) {
                node.neighbors = []; // Clear existing neighbors
                
                // Check all other leaf nodes for adjacency
                for (const other of this.leafNodes) {
                    if (node === other) continue;
                    
                    // Check if nodes are adjacent (including diagonals)
                    if (this._areNodesAdjacent(node, other)) {
                        node.neighbors.push(other);
                    }
                }
            }
        }
        
        _areNodesAdjacent(node1, node2) {
            // Check if two nodes share an edge or corner
            const margin = 5; // Small margin for floating point precision
            
            // Right edge of node1 touches left edge of node2
            if (Math.abs(node1.x + node1.width - node2.x) < margin &&
                !(node1.y + node1.height < node2.y + margin || node1.y > node2.y + node2.height - margin)) {
                return true;
            }
            
            // Left edge of node1 touches right edge of node2
            if (Math.abs(node1.x - (node2.x + node2.width)) < margin &&
                !(node1.y + node1.height < node2.y + margin || node1.y > node2.y + node2.height - margin)) {
                return true;
            }
            
            // Bottom edge of node1 touches top edge of node2
            if (Math.abs(node1.y + node1.height - node2.y) < margin &&
                !(node1.x + node1.width < node2.x + margin || node1.x > node2.x + node2.width - margin)) {
                return true;
            }
            
            // Top edge of node1 touches bottom edge of node2
            if (Math.abs(node1.y - (node2.y + node2.height)) < margin &&
                !(node1.x + node1.width < node2.x + margin || node1.x > node2.x + node2.width - margin)) {
                return true;
            }
            
            // Check corners (diagonal adjacency)
            if ((Math.abs(node1.x + node1.width - node2.x) < margin && 
                 Math.abs(node1.y + node1.height - node2.y) < margin) ||
                (Math.abs(node1.x - (node2.x + node2.width)) < margin && 
                 Math.abs(node1.y + node1.height - node2.y) < margin) ||
                (Math.abs(node1.x + node1.width - node2.x) < margin && 
                 Math.abs(node1.y - (node2.y + node2.height)) < margin) ||
                (Math.abs(node1.x - (node2.x + node2.width)) < margin && 
                 Math.abs(node1.y - (node2.y + node2.height)) < margin)) {
                return true;
            }
            
            return false;
        }
        
        findNode(x, y) {
            return this._findNodeRecursive(this.root, x, y);
        }
        
        _findNodeRecursive(node, x, y) {
            if (node.isLeaf) {
                return node;
            }
            
            for (const child of node.children) {
                if (child.contains(x, y)) {
                    return this._findNodeRecursive(child, x, y);
                }
            }
            
            return null;
        }
        
        findPath(startX, startY, endX, endY) {
            try {
                const startNode = this.findNode(startX, startY);
                const endNode = this.findNode(endX, endY);
                
                if (!startNode || !endNode || !startNode.walkable || !endNode.walkable) {
                    return null;
                }
                
                // Use A* to find path through nodes
                return this._aStar(startNode, endNode);
            } catch (error) {
                console.error("Error in findPath:", error);
                return null;
            }
        }
        
        _aStar(startNode, endNode) {
            const openSet = [startNode];
            const closedSet = [];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            
            gScore.set(startNode, 0);
            fScore.set(startNode, this._heuristic(startNode, endNode));
            
            while (openSet.length > 0) {
                // Find node with lowest fScore
                let current = openSet[0];
                let currentIndex = 0;
                
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore.get(openSet[i]) < fScore.get(current)) {
                        current = openSet[i];
                        currentIndex = i;
                    }
                }
                
                // Check if we've reached the goal
                if (current === endNode) {
                    return this._reconstructPath(cameFrom, current);
                }
                
                // Move current from openSet to closedSet
                openSet.splice(currentIndex, 1);
                closedSet.push(current);
                
                // Check all neighbors
                for (const neighbor of current.neighbors) {
                    if (closedSet.includes(neighbor)) {
                        continue;
                    }
                    
                    // Calculate tentative gScore
                    const tentativeGScore = gScore.get(current) + this._distance(current, neighbor);
                    
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                    } else if (tentativeGScore >= gScore.get(neighbor)) {
                        continue; // This is not a better path
                    }
                    
                    // This path is the best until now
                    cameFrom.set(neighbor, current);
                    gScore.set(neighbor, tentativeGScore);
                    fScore.set(neighbor, tentativeGScore + this._heuristic(neighbor, endNode));
                }
            }
            
            return null; // No path found
        }
        
        _heuristic(node1, node2) {
            // Euclidean distance between centers of nodes
            const dx = (node1.x + node1.width/2) - (node2.x + node2.width/2);
            const dy = (node1.y + node1.height/2) - (node2.y + node2.height/2);
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        _distance(node1, node2) {
            // Distance between centers of nodes
            const dx = (node1.x + node1.width/2) - (node2.x + node2.width/2);
            const dy = (node1.y + node1.height/2) - (node2.y + node2.height/2);
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        _reconstructPath(cameFrom, current) {
            const path = [current];
            
            while (cameFrom.has(current)) {
                current = cameFrom.get(current);
                path.unshift(current);
            }
            
            // Convert nodes to world coordinates (center of each node)
            return path.map(node => ({
                x: node.x + node.width / 2,
                y: node.y + node.height / 2
            }));
        }
        
        updateObstacles(walls, doors) {
            try {
                // Clear existing data
                this.leafNodes = [];
                this.nodeMap.clear();
                
                // Rebuild tree with updated obstacles
                this.buildTree(walls, doors);
            } catch (error) {
                console.error("Error updating obstacles:", error);
                // Ensure we always have a working pathfinder even if there's an error
                this.leafNodes = [];
                this.nodeMap.clear();
                
                // Create a simple fallback tree
                const fallbackNode = new QuadTreeNode(0, 0, this.root.width, this.root.height);
                fallbackNode.walkable = true;
                this.leafNodes.push(fallbackNode);
                this.nodeMap.set(fallbackNode.id, fallbackNode);
            }
        }
    }
    
    // ========== SOUND MANAGER ==========
    class SoundManager {
        constructor() {
            this.sounds = {};
            this.enabled = true;
            this.volume = 0.5;
        }
        
        load(name, src) {
            const audio = new Audio(src);
            this.sounds[name] = audio;
        }
        
        play(name, volume = 1.0) {
            if (!this.enabled || !this.sounds[name]) return;
            
            const sound = this.sounds[name].cloneNode();
            sound.volume = volume * this.volume;
            sound.play().catch(e => console.log('Sound play error:', e));
        }
        
        toggle() {
            this.enabled = !this.enabled;
            return this.enabled;
        }
    }
    
    const soundManager = new SoundManager();
    
    // ========== FLOATING TEXT CLASS ==========
    class FloatingText {
        constructor(x, y, text, color = '#ffffff', size = 20, speed = 1) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.size = size;
            this.speed = speed;
            this.life = 60;
            this.alpha = 1;
        }
        
        update() {
            this.y -= this.speed;
            this.life--;
            this.alpha = this.life / 60;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.font = `bold ${this.size}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }
    
    // ========== EXIT PORTAL CLASS ==========
    class ExitPortal {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 30;
            this.rotation = 0;
            this.pulsePhase = 0;
            this.active = false;
            this.particles = [];
        }
        
        update() {
            this.rotation += 0.02;
            this.pulsePhase += 0.05;
            
            if (Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * this.size;
                this.particles.push({
                    x: this.x + Math.cos(angle) * distance,
                    y: this.y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    size: Math.random() * 5 + 2,
                    life: 30
                });
            }
            
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                }
            }
        }
        
        draw(ctx) {
            for (const p of this.particles) {
                ctx.fillStyle = `rgba(0, 255, 255, ${p.life / 30})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            const pulseSize = this.size + Math.sin(this.pulsePhase) * 5;
            
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
            ctx.stroke();
            
            for (let i = 0; i < 3; i++) {
                ctx.rotate(Math.PI * 2 / 3);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                for (let j = 0; j < 20; j++) {
                    const angle = j / 20 * Math.PI;
                    const radius = pulseSize * (0.3 + 0.7 * (j % 2));
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                }
                ctx.strokeStyle = `rgba(255, 0, 255, ${0.7 - i * 0.2})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        checkCollision(player) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < player.size + this.size;
        }
    }
    
    // ========== BOSS CLASS ==========
    class Boss {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 50;
            this.angle = 0;
            this.health = 500;
            this.maxHealth = 500;
            this.speed = 0.3;
            this.attackCooldown = 0;
            this.phase = 1;
            this.projectiles = [];
            this.summonCooldown = 0;
            this.vulnerable = true; // Boss is now vulnerable
        }
        
        update() {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            this.angle = Math.atan2(dy, dx);
            
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            
            if (this.attackCooldown > 0) this.attackCooldown--;
            if (this.summonCooldown > 0) this.summonCooldown--;
            
            if (this.health < this.maxHealth * 0.5 && this.phase === 1) {
                this.phase = 2;
                createParticles(this.x, this.y, '#ff0000', 50, 5);
                shakeScreen(20);
            }
            
            if (this.attackCooldown <= 0) {
                if (this.phase === 1) {
                    this.shootProjectile();
                    this.attackCooldown = 80; // Increased cooldown
                } else {
                    this.shootShotgunSpread(); // Changed to shotgun spread
                    this.attackCooldown = 80; // Increased cooldown
                }
            }
            
            if (this.phase === 2 && this.summonCooldown <= 0) {
                this.summonMinions();
                this.summonCooldown = 180;
            }
            
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const proj = this.projectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;
                
                const dx = proj.x - player.x;
                const dy = proj.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < proj.size + player.size) {
                    if (!player.invulnerable && !player.isDead) {
                        player.health -= proj.damage;
                        player.invulnerable = true;
                        player.invulnerableTime = 60;
                        createBloodSplatter(player.x, player.y, 5);
                        shakeScreen(10);
                        updateHUD();
                        soundManager.play('playerHit');
                        
                        if (player.health <= 0) {
                            playerDeath();
                        }
                    }
                    
                    this.projectiles.splice(i, 1);
                    continue;
                }
                
                if (proj.life <= 0 || 
                    proj.x < 0 || proj.x > worldWidth || 
                    proj.y < 0 || proj.y > worldHeight) {
                    this.projectiles.splice(i, 1);
                }
            }
        }
        
        shootProjectile() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            
            this.projectiles.push({
                x: this.x,
                y: this.y,
                vx: Math.cos(angle) * 5,
                vy: Math.sin(angle) * 5,
                size: 10,
                damage: 20,
                life: 120,
                color: '#ff00ff'
            });
            
            createParticles(this.x, this.y, '#ff00ff', 10, 3);
        }
        
        shootShotgunSpread() {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            const pelletCount = 8; // More pellets for shotgun effect
            const spreadAngle = Math.PI / 8; // Spread angle
            
            for (let i = 0; i < pelletCount; i++) {
                const angle = baseAngle + (i - pelletCount/2) * spreadAngle / pelletCount;
                
                this.projectiles.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * 4, // Slightly slower
                    vy: Math.sin(angle) * 4,
                    size: 8, // Smaller pellets
                    damage: 15, // Less damage per pellet
                    life: 120,
                    color: '#ff00ff'
                });
            }
            
            createParticles(this.x, this.y, '#ff00ff', 20, 4);
        }
        
        summonMinions() {
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const distance = 100;
                const spawnX = this.x + Math.cos(angle) * distance;
                const spawnY = this.y + Math.sin(angle) * distance;
                
                enemies.push({
                    x: spawnX,
                    y: spawnY,
                    type: 'basic',
                    angle: 0,
                    attackCooldown: 0
                });
                
                const newEnemy = enemies[enemies.length - 1];
                const type = enemyTypes['basic'];
                Object.assign(newEnemy, {
                    health: type.health,
                    maxHealth: type.maxHealth,
                    speed: type.speed,
                    size: type.size,
                    color: type.color,
                    hasKnife: type.hasKnife,
                    attackDamage: type.attackDamage,
                    attackRange: type.attackRange,
                    detectionRange: type.detectionRange,
                    fireRate: type.fireRate || 60,
                    canShootThroughWalls: type.canShootThroughWalls || false,
                    bulletSpeed: type.bulletSpeed || 10,
                    path: [],
                    pathIndex: 0,
                    pathUpdateCounter: 0,
                    shouldFlash: false,
                    forcePathUpdate: false
                });
            }
            
            createParticles(this.x, this.y, '#9933ff', 30, 5);
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x - camera.x, this.y - camera.y);
            ctx.rotate(this.angle);
            
            // Boss body
            ctx.fillStyle = this.phase === 1 ? '#9900ff' : '#ff0099';
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss eyes
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(-this.size/3, -this.size/3, this.size/5, 0, Math.PI * 2);
            ctx.arc(this.size/3, -this.size/3, this.size/5, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss mouth
            ctx.beginPath();
            ctx.arc(0, this.size/4, this.size/3, 0, Math.PI);
            ctx.stroke();
            
            // Vulnerability indicator
            if (this.vulnerable) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
            
            // Draw projectiles
            for (const proj of this.projectiles) {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x - camera.x, proj.y - camera.y, proj.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Boss health bar
            const barWidth = 600;
            const barHeight = 20;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = 30;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
            
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('MEGA BOSS', canvas.width / 2, barY - 10);
            ctx.fillText(`PHASE ${this.phase}`, canvas.width / 2, barY + barHeight + 20);
        }
        
        takeDamage(damage) {
            if (!this.vulnerable) return false;
            
            this.health -= damage;
            createParticles(this.x, this.y, '#ff0000', 10, 3);
            shakeScreen(5);
            
            if (this.health <= 0) {
                createExplosion(this.x, this.y, 150);
                score += 5000;
                floatingTexts.push(new FloatingText(
                    this.x, 
                    this.y - this.size, 
                    '+5000 BOSS DEFEATED!', 
                    '#ffff00',
                    30
                ));
                soundManager.play('enemyDeath');
                unlockAchievement('bossSlayer');
                return true;
            }
            
            return false;
        }
    }
    
    // ========== ACHIEVEMENT SYSTEM ==========
    const achievements = [
        {
            id: 'firstKill',
            name: 'First Blood',
            description: 'Kill your first enemy',
            unlocked: false,
            check: () => kills >= 1
        },
        {
            id: 'comboMaster',
            name: 'Combo Master',
            description: 'Reach a 5x combo',
            unlocked: false,
            check: () => combo >= 5
        },
        {
            id: 'bossSlayer',
            name: 'Boss Slayer',
            description: 'Defeat the mega boss',
            unlocked: false,
            check: () => false
        },
        {
            id: 'perfectLevel',
            name: 'Perfect Level',
            description: 'Complete the level without taking damage',
            unlocked: false,
            check: () => levelComplete && player.health === player.maxHealth
        },
        {
            id: 'speedDemon',
            name: 'Speed Demon',
            description: 'Complete the level in under 2 minutes',
            unlocked: false,
            check: () => levelComplete && (Date.now() - levelStartTime) < 120000
        }
    ];
    
    let showAchievement = null;
    let achievementTimer = 0;
    
    function unlockAchievement(id) {
        const achievement = achievements.find(a => a.id === id);
        if (achievement && !achievement.unlocked) {
            achievement.unlocked = true;
            showAchievement = achievement;
            achievementTimer = 180;
            
            soundManager.play('pickup');
            
            score += 1000;
            floatingTexts.push(new FloatingText(
                player.x, 
                player.y - player.size - 30, 
                'ACHIEVEMENT UNLOCKED!', 
                '#ffff00',
                24
            ));
        }
    }
    
    function checkAchievements() {
        for (const achievement of achievements) {
            if (!achievement.unlocked && achievement.check()) {
                unlockAchievement(achievement.id);
            }
        }
    }
    
    // ========== INPUT HANDLING ==========
    const keys = {};
    const mouse = { x: 0, y: 0, isDown: false, wasDown: false };
    
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });
    
    canvas.addEventListener('mousedown', () => {
        mouse.isDown = true;
        if (player.shootCooldown === 0 && !player.isReloading && !player.isDead) {
            if (player.currentWeapon === 'pistol' && player.pistolAmmo > 0 && player.pistolSemiAuto) {
                shootPistol();
                player.pistolAmmo--;
                player.shootCooldown = weaponProperties.pistol.fireRate;
                player.pistolSemiAuto = false;
            } else if (player.currentWeapon === 'shotgun' && player.shotgunAmmo > 0 && player.isShotgunCocked) {
                shootShotgun();
                player.shotgunAmmo--;
                player.shootCooldown = weaponProperties.shotgun.fireRate;
                player.isShotgunCocked = false;
            } else if (player.currentWeapon === 'sniper' && player.sniperAmmo > 0 && player.isSniperReady) {
                shootSniper();
                player.sniperAmmo--;
                player.shootCooldown = weaponProperties.sniper.fireRate;
                player.isSniperReady = false;
            }
        }
    });
    
    canvas.addEventListener('mouseup', () => {
        mouse.isDown = false;
        player.pistolSemiAuto = true;
    });
    
    // ========== LEVEL INITIALIZATION ==========
    let pathfinder = null;
    
    function initLevel() {
        walls = [];
        doors = [];
        enemies = [];
        bloodSplatters = [];
        exitPortal = null;
        boss = null;
        
        // Set default player position in case spawn point isn't found
        player.x = worldWidth / 2;
        player.y = worldHeight / 2;
        
        const levelLayout = [
"####################################################################################################",
"#......#........#.....#........###......#.......................#.......................#........#",
"#..P............+........S......##......+...........N...........+..............H........+.......#",
"#..........#....#.....#.................#.......................#.......................#.......#",
"#######+##########+##########+#####################+##########+##########+##########+##########+#####",
"#        +            #          +            +          +#           +           +          +#    #",
"#   N    #    .-.     #   V      #   S        # .-.       # U         # .-.       #  S      # S   #",
"#        +            +          #            +           +           +           #          +#  #",
"#######+##########+##########+##########+##########+##########+##########+##########+##########+#####",
"#...............#......#................#.......................#.......................#.......#",
"###.....N.......+......#......S.......+..............H........+...........V...........+.......H#",
"###.............#.......................#.......................#.......................#.......#",
"#####+####+##########+##########+##########+##########+##########+##########+##########+##########+#",
"#          +#          +#          +#          +#          +#          +#          +#          +#",
"#   S      #   V      #   N      #   .-.     #   S      #   H      #   U      #   .-.     #  V   #",
"#          +#          +#          +#          +#          +#          +#          +#          +#",
"##########+##########+##########+##########+##########+##########+##########+##########+##########+#",
"###.............#.......................#.......................#.......................#.......#",
"###.....S.......+...............V.......+...............S.......+...............H.......+.......#",
"###.............#.......................#.......................#.......................#.......#",
"#################x########################x########################x########################x######",
"#...............#.......................#.......................#.......................#.......#",
"#.......N.......+...........S...........+...............U.......+...............H.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"####################################################################################################",
"#...............#.......................#.......................#.......................#.......#",
"#...............#.......................#.......................#.......................#.......#",
"#.......S.......+...............H.......+...............N.......+...............V.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"#######+##########+##########+##########+##########+##########+##########+##########+##########+#####",
"#       +#          +#          +#          +#          +#          +#          +#          +#    #",
"#   N     #   .-.     #   H      #   U      #   .-.     #   V      #   S      #   .-.     # S   #",
"#         +#          +#          +#          +#          +#          +#          +#          +#  #",
"#######+##########+##########+##########+##########+##########+##########+##########+##########+#####",
"#...............#.......................#.......................#.......................#.......#",
"#.......V.......+...............S.......+...............H.......+...............N.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"#################x########################x########################x########################x######",
"#...............#.......................#.......................#.......................#.......#",
"#.......U.......+...........V...........+...............S.......+...............H.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"####################################################################################################",
"#...............#.......................#.......................#.......................#.......#",
"#..S............+.............H.......+..............N........+...........V...........+.......>#",
"#...............#.......................#.......................#.......................#.......#",
"####################################################################################################",
];
        
        const tileSize = 60;
        const levelWidth = levelLayout[0].length * tileSize;
        const levelHeight = levelLayout.length * tileSize;
        const offsetX = (worldWidth - levelWidth) / 2;
        const offsetY = (worldHeight - levelHeight) / 2;
        
        console.log(`Level dimensions: ${levelWidth}x${levelHeight}`);
        console.log(`World dimensions: ${worldWidth}x${worldHeight}`);
        console.log(`Level offset: ${offsetX}x${offsetY}`);
        
        let playerSpawned = false;
        
        for (let row = 0; row < levelLayout.length; row++) {
            for (let col = 0; col < levelLayout[row].length; col++) {
                const char = levelLayout[row][col];
                const x = offsetX + col * tileSize;
                const y = offsetY + row * tileSize;
                
                switch (char) {
                    case '#':
                        walls.push({ 
                            x: x, 
                            y: y, 
                            width: tileSize, 
                            height: tileSize, 
                            type: 'interior' 
                        });
                        break;
                        
                    case '+':
                        doors.push({ 
                            x: x, 
                            y: y, 
                            width: tileSize, 
                            height: tileSize, 
                            health: 2, 
                            maxHealth: 2, 
                            isBroken: false,
                            wasBroken: false
                        });
                        break;
                        
                    case 'x':
                        doors.push({ 
                            x: x, 
                            y: y, 
                            width: tileSize, 
                            height: tileSize, 
                            health: 5, 
                            maxHealth: 5, 
                            isBroken: false,
                            wasBroken: false
                        });
                        break;
                        
                    case 'P':
                        player.x = x + tileSize / 2;
                        player.y = y + tileSize / 2;
                        playerSpawned = true;
                        console.log(`Player spawned at: ${player.x}, ${player.y}`);
                        break;
                        
                    case 'E':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'basic', 
                            angle: 0, 
                            attackCooldown: 0 
                        });
                        break;
                        
                    case 'H':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'shield', 
                            angle: 0, 
                            attackCooldown: 0 
                        });
                        break;
                        
                    case 'S':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'spawner', 
                            angle: 0, 
                            attackCooldown: 0 
                        });
                        break;
                        
                    case 'U':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'suicide', 
                            angle: 0, 
                            attackCooldown: 0 
                        });
                        break;
                        
                    case 'N':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'sniper', 
                            angle: 0, 
                            attackCooldown: 0 
                        });
                        break;
                        
                    case 'V':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'heavy', 
                            angle: 0, 
                            attackCooldown: 0 
                        });
                        break;
                        
                    case '>':
                        exitPortal = new ExitPortal(x + tileSize / 2, y + tileSize / 2);
                        break;
                        
                    case 'B':
                        boss = new Boss(x + tileSize / 2, y + tileSize / 2);
                        break;
                }
            }
        }
        
        if (!playerSpawned) {
            console.warn('Player spawn point (P) not found in level layout!');
            player.x = offsetX + tileSize * 3 + tileSize / 2;
            player.y = offsetY + tileSize * 3 + tileSize / 2;
            console.log(`Player spawned at fallback position: ${player.x}, ${player.y}`);
        }
        
        // Ensure player position is valid
        if (isNaN(player.x) || isNaN(player.y)) {
            console.error('Player position is NaN! Setting to center of world.');
            player.x = worldWidth / 2;
            player.y = worldHeight / 2;
        }
        
        // Clamp player position to world bounds
        player.x = Math.max(player.size, Math.min(worldWidth - player.size, player.x));
        player.y = Math.max(player.size, Math.min(worldHeight - player.size, player.y));
        
        console.log(`Final player position: ${player.x}, ${player.y}`);
        
        for (const enemy of enemies) {
            const type = enemyTypes[enemy.type];
            Object.assign(enemy, {
                health: type.health,
                maxHealth: type.maxHealth,
                speed: type.speed,
                size: type.size,
                color: type.color,
                hasKnife: type.hasKnife,
                attackDamage: type.attackDamage,
                attackRange: type.attackRange,
                detectionRange: type.detectionRange,
                fireRate: type.fireRate || 60,
                canShootThroughWalls: type.canShootThroughWalls || false,
                bulletSpeed: type.bulletSpeed || 10,
                path: [],
                pathIndex: 0,
                pathUpdateCounter: 0,
                shouldFlash: false,
                forcePathUpdate: false
            });
            
            if (enemy.type === 'shield') {
                enemy.hasShield = true;
                enemy.shieldHealth = type.shieldHealth;
                enemy.shieldMaxHealth = type.shieldMaxHealth;
            }
        }
        
        // Initialize door wasBroken property
        for (const door of doors) {
            door.wasBroken = door.isBroken;
        }
        
        // Initialize quadtree pathfinder
        pathfinder = new QuadTree(worldWidth, worldHeight);
        pathfinder.buildTree(walls, doors);
    }
    
    function loadSounds() {
        // Create dummy sound objects to avoid errors
        soundManager.load('pistol', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('shotgun', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('sniper', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('enemyHit', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('enemyDeath', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('playerHit', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('doorBreak', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('portal', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('pickup', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
    }
    
    // ========== LINE OF SIGHT FUNCTION ==========
    function hasLineOfSight(x1, y1, x2, y2) {
        // Check if there's a wall or unbroken door blocking the line between two points
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // We'll check in small steps along the line
        const steps = Math.ceil(distance / 10); // Check every 10 pixels
        const stepX = dx / steps;
        const stepY = dy / steps;
        
        for (let i = 1; i <= steps; i++) {
            const checkX = x1 + stepX * i;
            const checkY = y1 + stepY * i;
            
            // Check walls
            for (const wall of walls) {
                if (checkX >= wall.x && checkX <= wall.x + wall.width &&
                    checkY >= wall.y && checkY <= wall.y + wall.height) {
                    return false;
                }
            }
            
            // Check doors (only unbroken doors block)
            for (const door of doors) {
                if (!door.isBroken &&
                    checkX >= door.x && checkX <= door.x + door.width &&
                    checkY >= door.y && checkY <= door.y + door.height) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    // ========== UPDATE FUNCTIONS ==========
    function updatePlayer() {
        if (player.isDead) return;
        
        if (keys['1']) {
            player.currentWeapon = 'pistol';
            keys['1'] = false;
        }
        if (keys['2']) {
            player.currentWeapon = 'shotgun';
            keys['2'] = false;
        }
        if (keys['3']) {
            player.currentWeapon = 'sniper';
            keys['3'] = false;
        }
        
        if (keys['r'] && !player.isReloading) {
            const weapon = player.currentWeapon;
            if (weapon === 'pistol' && player.pistolAmmo < weaponProperties.pistol.maxAmmo) {
                player.isReloading = true;
                player.reloadTime = weaponProperties.pistol.reloadTime;
            } else if (weapon === 'shotgun' && player.shotgunAmmo < weaponProperties.shotgun.maxAmmo) {
                player.isReloading = true;
                player.reloadTime = weaponProperties.shotgun.reloadTime;
            } else if (weapon === 'sniper' && player.sniperAmmo < weaponProperties.sniper.maxAmmo) {
                player.isReloading = true;
                player.reloadTime = weaponProperties.sniper.reloadTime;
            }
        }
        
        if (keys['c'] && player.currentWeapon === 'shotgun' && !player.isShotgunCocked) {
            player.isShotgunCocked = true;
            createParticles(player.x, player.y, '#ff9900', 5, 2);
        }
        
        if (keys['v'] && player.currentWeapon === 'sniper' && !player.isSniperReady) {
            player.isSniperReady = true;
            createParticles(player.x, player.y, '#00ffff', 5, 2);
        }
        
        if (keys['f'] && player.kickCooldown === 0) {
            playerKick();
            player.kickCooldown = 30;
        }
        
        if (keys['m']) {
            soundManager.toggle();
            keys['m'] = false;
            floatingTexts.push(new FloatingText(
                player.x, 
                player.y - player.size - 20, 
                `Sound ${soundManager.enabled ? 'ON' : 'OFF'}`, 
                '#ffffff',
                16
            ));
        }
        
        if (player.isReloading) {
            player.reloadTime--;
            if (player.reloadTime <= 0) {
                const weapon = player.currentWeapon;
                if (weapon === 'pistol') {
                    player.pistolAmmo = weaponProperties.pistol.maxAmmo;
                } else if (weapon === 'shotgun') {
                    player.shotgunAmmo = weaponProperties.shotgun.maxAmmo;
                } else if (weapon === 'sniper') {
                    player.sniperAmmo = weaponProperties.sniper.maxAmmo;
                }
                player.isReloading = false;
            }
        }
        
        if (player.kickCooldown > 0) player.kickCooldown--;
        
        if (player.invulnerable) {
            player.invulnerableTime--;
            if (player.invulnerableTime <= 0) {
                player.invulnerable = false;
            }
        }
        
        let dx = 0, dy = 0;
        if (keys['w']) dy -= player.speed;
        if (keys['s']) dy += player.speed;
        if (keys['a']) dx -= player.speed;
        if (keys['d']) dx += player.speed;
        
        if (dx !== 0 && dy !== 0) {
            dx *= 0.707;
            dy *= 0.707;
        }
        
        const newX = player.x + dx;
        const newY = player.y + dy;
        
        let canMoveX = true;
        let canMoveY = true;
        
        for (const wall of walls) {
            if (newX - player.size < wall.x + wall.width &&
                newX + player.size > wall.x &&
                player.y - player.size < wall.y + wall.height &&
                player.y + player.size > wall.y) {
                canMoveX = false;
            }
            
            if (player.x - player.size < wall.x + wall.width &&
                player.x + player.size > wall.x &&
                newY - player.size < wall.y + wall.height &&
                newY + player.size > wall.y) {
                canMoveY = false;
            }
        }
        
        for (const door of doors) {
            if (!door.isBroken) {
                if (newX - player.size < door.x + door.width &&
                    newX + player.size > door.x &&
                    player.y - player.size < door.y + door.height &&
                    player.y + player.size > door.y) {
                    canMoveX = false;
                }
                
                if (player.x - player.size < door.x + door.width &&
                    player.x + player.size > door.x &&
                    newY - player.size < door.y + door.height &&
                    newY + player.size > door.y) {
                    canMoveY = false;
                }
            }
        }
        
        if (canMoveX) player.x = newX;
        if (canMoveY) player.y = newY;
        
        player.x = Math.max(player.size, Math.min(worldWidth - player.size, player.x));
        player.y = Math.max(player.size, Math.min(worldHeight - player.size, player.y));
        
        const mouseWorldX = mouse.x + camera.x;
        const mouseWorldY = mouse.y + camera.y;
        player.angle = Math.atan2(mouseWorldY - player.y, mouseWorldX - player.x);
        
        if (player.shootCooldown > 0) player.shootCooldown--;
    }
    
    function updateCamera() {
        if (camera.x === 0 && camera.y === 0) {
            camera.x = player.x - camera.width / 2;
            camera.y = player.y - camera.height / 2;
            
            camera.x = Math.max(0, Math.min(worldWidth - camera.width, camera.x));
            camera.y = Math.max(0, Math.min(worldHeight - camera.height, camera.y));
            
            console.log(`Camera initialized at: ${camera.x}, ${camera.y}`);
            return;
        }
        const targetX = player.x - camera.width / 2;
        const targetY = player.y - camera.height / 2;
        
        camera.x += (targetX - camera.x) * camera.followSpeed;
        camera.y += (targetY - camera.y) * camera.followSpeed;
        
        camera.x = Math.max(0, Math.min(worldWidth - camera.width, camera.x));
        camera.y = Math.max(0, Math.min(worldHeight - camera.height, camera.y));
    }
    
    function updateEnemies() {
        // Update pathfinder if any door was broken
        let doorBroken = false;
        for (const door of doors) {
            if (!door.wasBroken && door.isBroken) {
                door.wasBroken = true;
                doorBroken = true;
            }
        }
        
        if (doorBroken) {
            try {
                // Completely rebuild the pathfinder when a door breaks
                pathfinder = new QuadTree(worldWidth, worldHeight);
                pathfinder.buildTree(walls, doors);
                
                // Force all enemies to recalculate their paths
                for (const enemy of enemies) {
                    enemy.forcePathUpdate = true;
                    enemy.path = [];
                    enemy.pathUpdateCounter = 0; // Force immediate recalculation
                }
            } catch (error) {
                console.error("Error updating pathfinder:", error);
                // Fallback: clear all paths without crashing
                for (const enemy of enemies) {
                    enemy.path = [];
                }
            }
        }
        
        for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < enemy.detectionRange) {
                // Check if there's a clear line of sight to the player
                const hasClearPath = hasLineOfSight(enemy.x, enemy.y, player.x, player.y);
                
                if (hasClearPath) {
                    // Use direct movement when there's a clear path
                    const dirX = dx / distance;
                    const dirY = dy / distance;
                    
                    let moveX = dirX * enemy.speed;
                    let moveY = dirY * enemy.speed;
                    
                    // Check collision with walls and doors separately for X and Y
                    let canMoveX = true;
                    let canMoveY = true;
                    
                    // Test X movement
                    const testX = enemy.x + moveX;
                    for (const wall of walls) {
                        if (testX - enemy.size < wall.x + wall.width &&
                            testX + enemy.size > wall.x &&
                            enemy.y - enemy.size < wall.y + wall.height &&
                            enemy.y + enemy.size > wall.y) {
                            canMoveX = false;
                            break;
                        }
                    }
                    
                    if (canMoveX) {
                        for (const door of doors) {
                            if (!door.isBroken &&
                                testX - enemy.size < door.x + door.width &&
                                testX + enemy.size > door.x &&
                                enemy.y - enemy.size < door.y + door.height &&
                                enemy.y + enemy.size > door.y) {
                                canMoveX = false;
                                
                                // Attack door if close
                                const doorDist = Math.sqrt(
                                    Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                    Math.pow(enemy.y - (door.y + door.height/2), 2)
                                );
                                
                                if (doorDist < enemy.size + 20) {
                                    door.health--;
                                    createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                    
                                    if (door.health <= 0) {
                                        door.isBroken = true;
                                        createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                        shakeScreen(5);
                                        soundManager.play('doorBreak');
                                    }
                                }
                                break;
                            }
                        }
                    }
                    
                    // Test Y movement
                    const testY = enemy.y + moveY;
                    for (const wall of walls) {
                        if (enemy.x - enemy.size < wall.x + wall.width &&
                            enemy.x + enemy.size > wall.x &&
                            testY - enemy.size < wall.y + wall.height &&
                            testY + enemy.size > wall.y) {
                            canMoveY = false;
                            break;
                        }
                    }
                    
                    if (canMoveY) {
                        for (const door of doors) {
                            if (!door.isBroken &&
                                enemy.x - enemy.size < door.x + door.width &&
                                enemy.x + enemy.size > door.x &&
                                testY - enemy.size < door.y + door.height &&
                                testY + enemy.size > door.y) {
                                canMoveY = false;
                                
                                // Attack door if close
                                const doorDist = Math.sqrt(
                                    Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                    Math.pow(enemy.y - (door.y + door.height/2), 2)
                                );
                                
                                if (doorDist < enemy.size + 20) {
                                    door.health--;
                                    createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                    
                                    if (door.health <= 0) {
                                        door.isBroken = true;
                                        createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                        shakeScreen(5);
                                        soundManager.play('doorBreak');
                                    }
                                }
                                break;
                            }
                        }
                    }
                    
                    // Move if no collision
                    if (canMoveX) enemy.x += moveX;
                    if (canMoveY) enemy.y += moveY;
                    
                    // Update enemy angle to face player
                    enemy.angle = Math.atan2(dy, dx);
                } else {
                    // Use pathfinding when obstacles are in the way
                    enemy.pathUpdateCounter--;
                    
                    // Check if we need a new path
                    const playerMovedSignificantly = enemy.lastPlayerX && enemy.lastPlayerY && 
                        (Math.abs(player.x - enemy.lastPlayerX) > 150 || 
                         Math.abs(player.y - enemy.lastPlayerY) > 150);
                    
                    if (enemy.pathUpdateCounter <= 0 || !enemy.path || enemy.path.length === 0 || 
                        enemy.forcePathUpdate || playerMovedSignificantly) {
                        
                        try {
                            // Find path using quadtree
                            const newPath = pathfinder.findPath(enemy.x, enemy.y, player.x, player.y);
                            
                            if (newPath && newPath.length > 0) {
                                enemy.path = newPath;
                                enemy.pathIndex = 0;
                                enemy.pathUpdateCounter = 30; // Update path every 30 frames
                                enemy.forcePathUpdate = false;
                                
                                // Store current player position
                                enemy.lastPlayerX = player.x;
                                enemy.lastPlayerY = player.y;
                                
                                // Initialize stuck counter if not exists
                                if (!enemy.pathStuckCounter) {
                                    enemy.pathStuckCounter = 30;
                                    enemy.lastPosition = { x: enemy.x, y: enemy.y };
                                }
                            } else {
                                // If no path found, clear path to use direct movement
                                enemy.path = [];
                            }
                        } catch (error) {
                            console.error("Pathfinding error:", error);
                            enemy.path = []; // Clear path on error
                        }
                    }
                    
                    // Move along path if available
                    if (enemy.path && enemy.path.length > 0 && enemy.pathIndex < enemy.path.length) {
                        const targetPoint = enemy.path[enemy.pathIndex];
                        
                        // Calculate direction to target point
                        const dirX = targetPoint.x - enemy.x;
                        const dirY = targetPoint.y - enemy.y;
                        const dirDistance = Math.sqrt(dirX * dirX + dirY * dirY);
                        
                        // If close enough to current point, move to next point
                        if (dirDistance < 25) {
                            enemy.pathIndex++;
                            if (enemy.pathIndex >= enemy.path.length) {
                                // Reached end of path, try to get closer to player directly
                                enemy.path = [];
                            }
                        } else {
                            // Normalize direction and apply speed
                            const moveX = (dirX / dirDistance) * enemy.speed;
                            const moveY = (dirY / dirDistance) * enemy.speed;
                            
                            // Check collision with walls and doors separately for X and Y
                            let canMoveX = true;
                            let canMoveY = true;
                            
                            // Test X movement
                            const testX = enemy.x + moveX;
                            for (const wall of walls) {
                                if (testX - enemy.size < wall.x + wall.width &&
                                    testX + enemy.size > wall.x &&
                                    enemy.y - enemy.size < wall.y + wall.height &&
                                    enemy.y + enemy.size > wall.y) {
                                    canMoveX = false;
                                    break;
                                }
                            }
                            
                            if (canMoveX) {
                                for (const door of doors) {
                                    if (!door.isBroken &&
                                        testX - enemy.size < door.x + door.width &&
                                        testX + enemy.size > door.x &&
                                        enemy.y - enemy.size < door.y + door.height &&
                                        enemy.y + enemy.size > door.y) {
                                        canMoveX = false;
                                        
                                        // Attack door if close
                                        const doorDist = Math.sqrt(
                                            Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                            Math.pow(enemy.y - (door.y + door.height/2), 2)
                                        );
                                        
                                        if (doorDist < enemy.size + 20) {
                                            door.health--;
                                            createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                            
                                            if (door.health <= 0) {
                                                door.isBroken = true;
                                                createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                                shakeScreen(5);
                                                soundManager.play('doorBreak');
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            
                            // Test Y movement
                            const testY = enemy.y + moveY;
                            for (const wall of walls) {
                                if (enemy.x - enemy.size < wall.x + wall.width &&
                                    enemy.x + enemy.size > wall.x &&
                                    testY - enemy.size < wall.y + wall.height &&
                                    testY + enemy.size > wall.y) {
                                    canMoveY = false;
                                    break;
                                }
                            }
                            
                            if (canMoveY) {
                                for (const door of doors) {
                                    if (!door.isBroken &&
                                        enemy.x - enemy.size < door.x + door.width &&
                                        enemy.x + enemy.size > door.x &&
                                        testY - enemy.size < door.y + door.height &&
                                        testY + enemy.size > door.y) {
                                        canMoveY = false;
                                        
                                        // Attack door if close
                                        const doorDist = Math.sqrt(
                                            Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                            Math.pow(enemy.y - (door.y + door.height/2), 2)
                                        );
                                        
                                        if (doorDist < enemy.size + 20) {
                                            door.health--;
                                            createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                            
                                            if (door.health <= 0) {
                                                door.isBroken = true;
                                                createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                                shakeScreen(5);
                                                soundManager.play('doorBreak');
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            
                            // Move if no collision
                            if (canMoveX) enemy.x += moveX;
                            if (canMoveY) enemy.y += moveY;
                            
                            // Check if enemy actually moved (not stuck)
                            if (enemy.lastPosition) {
                                const distFromLastPos = Math.sqrt(
                                    Math.pow(enemy.x - enemy.lastPosition.x, 2) + 
                                    Math.pow(enemy.y - enemy.lastPosition.y, 2)
                                );
                                
                                if (distFromLastPos < 0.5) { // If barely moved
                                    enemy.pathStuckCounter--;
                                    if (enemy.pathStuckCounter <= 0) {
                                        // Enemy is stuck, force path recalculation
                                        enemy.forcePathUpdate = true;
                                        enemy.path = [];
                                        enemy.pathStuckCounter = 30; // Reset counter
                                    }
                                } else {
                                    // Enemy is moving, reset stuck counter
                                    enemy.pathStuckCounter = 30;
                                    enemy.lastPosition = { x: enemy.x, y: enemy.y };
                                }
                            }
                        }
                    } else if (!enemy.path || enemy.path.length === 0) {
                        // If no path, try direct movement (simple approach)
                        const dirX = player.x - enemy.x;
                        const dirY = player.y - enemy.y;
                        const dirDistance = Math.sqrt(dirX * dirX + dirY * dirY);
                        
                        if (dirDistance > 0) {
                            const moveX = (dirX / dirDistance) * enemy.speed;
                            const moveY = (dirY / dirDistance) * enemy.speed;
                            
                            let canMoveX = true;
                            let canMoveY = true;
                            const testX = enemy.x + moveX;
                            const testY = enemy.y + moveY;
                            
                            // Check collision with walls
                            for (const wall of walls) {
                                if (testX - enemy.size < wall.x + wall.width &&
                                    testX + enemy.size > wall.x &&
                                    enemy.y - enemy.size < wall.y + wall.height &&
                                    enemy.y + enemy.size > wall.y) {
                                    canMoveX = false;
                                }
                                
                                if (enemy.x - enemy.size < wall.x + wall.width &&
                                    enemy.x + enemy.size > wall.x &&
                                    testY - enemy.size < wall.y + wall.height &&
                                    testY + enemy.size > wall.y) {
                                    canMoveY = false;
                                }
                            }
                            
                            // Check collision with doors
                            for (const door of doors) {
                                if (!door.isBroken) {
                                    if (testX - enemy.size < door.x + door.width &&
                                        testX + enemy.size > door.x &&
                                        enemy.y - enemy.size < door.y + door.height &&
                                        enemy.y + enemy.size > door.y) {
                                        canMoveX = false;
                                    }
                                    
                                    if (enemy.x - enemy.size < door.x + door.width &&
                                        enemy.x + enemy.size > door.x &&
                                        testY - enemy.size < door.y + door.height &&
                                        testY + enemy.size > door.y) {
                                        canMoveY = false;
                                    }
                                }
                            }
                            
                            if (canMoveX) enemy.x += moveX;
                            if (canMoveY) enemy.y += moveY;
                        }
                    }
                    
                    // Update enemy angle to face player
                    enemy.angle = Math.atan2(dy, dx);
                }
                
                // Handle enemy attacks
                if (enemy.type === 'suicide' && distance < enemy.attackRange) {
                    enemy.shouldFlash = (Math.floor(enemy.attackCooldown / 5) % 2 === 0);
                    
                    if (enemy.attackCooldown <= 0) {
                        createExplosion(enemy.x, enemy.y, enemy.explosionRadius);
                        
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < enemy.explosionRadius) {
                            const damage = enemy.attackDamage * (1 - distance / enemy.explosionRadius);
                            if (!player.invulnerable && !player.isDead) {
                                player.health -= damage;
                                player.invulnerable = true;
                                player.invulnerableTime = 60;
                                createBloodSplatter(player.x, player.y, 5);
                                shakeScreen(15);
                                updateHUD();
                                soundManager.play('playerHit');
                                
                                if (player.health <= 0) {
                                    playerDeath();
                                }
                            }
                        }
                        
                        enemies.splice(j, 1);
                        continue;
                    }
                }
                
                if (enemy.type === 'spawner' && enemy.canSpawn && enemy.spawnCooldown <= 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const spawnX = enemy.x + Math.cos(angle) * enemy.spawnRadius;
                    const spawnY = enemy.y + Math.sin(angle) * enemy.spawnRadius;
                    
                    enemies.push({
                        x: spawnX,
                        y: spawnY,
                        type: 'basic',
                        angle: 0,
                        attackCooldown: 0
                    });
                    
                    const newEnemy = enemies[enemies.length - 1];
                    const type = enemyTypes['basic'];
                    Object.assign(newEnemy, {
                        health: type.health,
                        maxHealth: type.maxHealth,
                        speed: type.speed,
                        size: type.size,
                        color: type.color,
                        hasKnife: type.hasKnife,
                        attackDamage: type.attackDamage,
                        attackRange: type.attackRange,
                        detectionRange: type.detectionRange,
                        fireRate: type.fireRate || 60,
                        canShootThroughWalls: type.canShootThroughWalls || false,
                        bulletSpeed: type.bulletSpeed || 10,
                        path: [],
                        pathIndex: 0,
                        pathUpdateCounter: 0,
                        shouldFlash: false,
                        forcePathUpdate: false
                    });
                    
                    enemy.spawnCooldown = 180;
                    createParticles(spawnX, spawnY, '#9933ff', 20, 3);
                }
                
                if (enemy.type === 'basic' || enemy.type === 'heavy' || enemy.type === 'shield') {
                    if (enemy.hasKnife && distance < enemy.attackRange) {
                        if (enemy.attackCooldown <= 0) {
                            enemyAttack(enemy);
                            enemy.attackCooldown = 60;
                        }
                    }
                } else if (enemy.type === 'sniper') {
                    if (distance < enemy.attackRange && enemy.attackCooldown <= 0) {
                        enemyShoot(enemy);
                        enemy.attackCooldown = enemy.fireRate;
                    }
                }
                
                if (enemy.attackCooldown > 0) enemy.attackCooldown--;
                if (enemy.spawnCooldown > 0) enemy.spawnCooldown--;
            }
        }
    }
    
    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            
            bullet.x += Math.cos(bullet.angle) * bullet.speed;
            bullet.y += Math.sin(bullet.angle) * bullet.speed;
            bullet.distance += bullet.speed;
            
            if (bullet.distance > bullet.maxDistance) {
                bullets.splice(i, 1);
                continue;
            }
            
            if (!bullet.canPassThroughWalls) {
                let hitWall = false;
                for (const wall of walls) {
                    if (bullet.x + bullet.size > wall.x && 
                        bullet.x - bullet.size < wall.x + wall.width &&
                        bullet.y + bullet.size > wall.y && 
                        bullet.y - bullet.size < wall.y + wall.height) {
                        
                        const bulletLeft = bullet.x - bullet.size;
                        const bulletRight = bullet.x + bullet.size;
                        const bulletTop = bullet.y - bullet.size;
                        const bulletBottom = bullet.y + bullet.size;
                        
                        const wallLeft = wall.x;
                        const wallRight = wall.x + wall.width;
                        const wallTop = wall.y;
                        const wallBottom = wall.y + wall.height;
                        
                        const overlapLeft = bulletRight - wallLeft;
                        const overlapRight = wallRight - bulletLeft;
                        const overlapTop = bulletBottom - wallTop;
                        const overlapBottom = wallBottom - bulletTop;
                        
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                        
                        if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                            bullet.angle = Math.PI - bullet.angle;
                        } else {
                            bullet.angle = -bullet.angle;
                        }
                        
                        if (minOverlap === overlapLeft) {
                            bullet.x = wallLeft - bullet.size;
                        } else if (minOverlap === overlapRight) {
                            bullet.x = wallRight + bullet.size;
                        } else if (minOverlap === overlapTop) {
                            bullet.y = wallTop - bullet.size;
                        } else {
                            bullet.y = wallBottom + bullet.size;
                        }
                        
                        createParticles(bullet.x, bullet.y, '#ff00ff', 5, 2);
                        
                        bullet.bounces--;
                        if (bullet.bounces <= 0) {
                            bullets.splice(i, 1);
                        }
                        
                        hitWall = true;
                        break;
                    }
                }
                
                if (hitWall) continue;
            }
            
            if (!bullet.canPassThroughWalls) {
                for (const door of doors) {
                    if (!door.isBroken &&
                        bullet.x + bullet.size > door.x && 
                        bullet.x - bullet.size < door.x + door.width &&
                        bullet.y + bullet.size > door.y && 
                        bullet.y - bullet.size < door.y + door.height) {
                        
                        door.health--;
                        createParticles(bullet.x, bullet.y, '#ffff00', 10, 3);
                        
                        if (door.health <= 0) {
                            door.isBroken = true;
                            createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                            shakeScreen(10);
                            soundManager.play('doorBreak');
                        }
                        
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }
            
            if (!bullet.isEnemyBullet) {
                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bullet.size + enemy.size) {
                        if (enemy.type === 'shield' && enemy.hasShield) {
                            enemy.shieldHealth -= bullet.damage;
                            createParticles(bullet.x, bullet.y, '#0099ff', 5, 2);
                            
                            if (enemy.shieldHealth <= 0) {
                                enemy.hasShield = false;
                                createParticles(enemy.x, enemy.y, '#0099ff', 20, 5);
                                shakeScreen(5);
                            }
                            
                            bullets.splice(i, 1);
                            break;
                        }
                        
                        enemy.health -= bullet.damage;
                        createParticles(bullet.x, bullet.y, '#ff0000', 5, 2);
                        
                        if (enemy.health <= 0) {
                            if (enemy.type === 'suicide' && enemy.explodesOnDeath) {
                                createExplosion(enemy.x, enemy.y, enemy.explosionRadius);
                            }
                            
                            enemies.splice(j, 1);
                            kills++;
                            
                            let points = 0;
                            switch (enemy.type) {
                                case 'basic': points = 100; break;
                                case 'sniper': points = 250; break;
                                case 'heavy': points = 500; break;
                                case 'shield': points = 400; break;
                                case 'suicide': points = 300; break;
                                case 'spawner': points = 750; break;
                            }
                            
                            const comboMultiplier = Math.min(combo, 10);
                            points *= comboMultiplier;
                            
                            score += points;
                            
                            let comboText = combo > 1 ? ` x${combo} COMBO!` : '';
                            floatingTexts.push(new FloatingText(
                                enemy.x, 
                                enemy.y - enemy.size, 
                                `+${points}${comboText}`, 
                                combo > 1 ? '#ffff00' : '#00ff00'
                            ));
                            
                            const now = Date.now();
                            if (now - lastKillTime < 2000) {
                                combo++;
                            } else {
                                combo = 1;
                            }
                            lastKillTime = now;
                            
                            createBloodSplatter(enemy.x, enemy.y, 10);
                            shakeScreen(5);
                            soundManager.play('enemyDeath');
                            
                            updateHUD();
                            checkAchievements();
                        }
                        
                        if (!bullet.canPassThroughWalls) {
                            bullets.splice(i, 1);
                        }
                        break;
                    }
                }
                
                // Check collision with boss
                if (boss) {
                    const dx = bullet.x - boss.x;
                    const dy = bullet.y - boss.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bullet.size + boss.size) {
                        if (boss.takeDamage(bullet.damage)) {
                            boss = null;
                        }
                        
                        if (!bullet.canPassThroughWalls) {
                            bullets.splice(i, 1);
                        }
                    }
                }
            }
            
            if (bullet.isEnemyBullet) {
                const dx = bullet.x - player.x;
                const dy = bullet.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < bullet.size + player.size) {
                    if (!player.invulnerable && !player.isDead) {
                        player.health -= bullet.damage;
                        player.invulnerable = true;
                        player.invulnerableTime = 60;
                        createBloodSplatter(player.x, player.y, 5);
                        shakeScreen(10);
                        updateHUD();
                        soundManager.play('playerHit');
                        
                        if (player.health <= 0) {
                            playerDeath();
                        }
                    }
                    
                    bullets.splice(i, 1);
                }
            }
        }
    }
    
    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            
            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }
    
    function updateFloatingTexts() {
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            const text = floatingTexts[i];
            text.update();
            if (text.life <= 0) {
                floatingTexts.splice(i, 1);
            }
        }
    }
    
    // ========== HELPER FUNCTIONS ==========
    function lineIntersectsRect(x1, y1, x2, y2, rectX1, rectY1, rectX2, rectY2) {
        if ((x1 >= rectX1 && x1 <= rectX2 && y1 >= rectY1 && y1 <= rectY2) ||
            (x2 >= rectX1 && x2 <= rectX2 && y2 >= rectY1 && y2 <= rectY2)) {
            return true;
        }
        
        if (lineIntersectsLine(x1, y1, x2, y2, rectX1, rectY1, rectX1, rectY2)) return true;
        if (lineIntersectsLine(x1, y1, x2, y2, rectX2, rectY1, rectX2, rectY2)) return true;
        if (lineIntersectsLine(x1, y1, x2, y2, rectX1, rectY1, rectX2, rectY1)) return true;
        if (lineIntersectsLine(x1, y1, x2, y2, rectX1, rectY2, rectX2, rectY2)) return true;
        
        return false;
    }
    
    function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        if (denominator === 0) return false;
        
        const ua = (((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator);
        const ub = (((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator);
        
        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
    }
    
    function createExplosion(x, y, radius) {
        for (let i = 0; i < 50; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 5 + 2;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * 8 + 4,
                color: `hsl(${Math.random() * 60}, 100%, 50%)`,
                life: 30
            });
        }
        
        shakeScreen(20);
        soundManager.play('enemyDeath');
    }
    
    function shakeScreen(intensity) {
        camera.shakeIntensity = intensity;
    }
    
    // ========== ACTION FUNCTIONS ==========
    function shootPistol() {
        bullets.push({
            x: player.x,
            y: player.y,
            angle: player.angle,
            speed: weaponProperties.pistol.bulletSpeed,
            size: 4,
            distance: 0,
            maxDistance: weaponProperties.pistol.bulletRange,
            bounces: weaponProperties.pistol.bounces,
            damage: weaponProperties.pistol.damage,
            weapon: 'pistol',
            canPassThroughWalls: false
        });
        
        createParticles(player.x, player.y, weaponProperties.pistol.color, 5, 2);
        soundManager.play('pistol');
    }
    
    function shootShotgun() {
        const pelletCount = weaponProperties.shotgun.pelletCount;
        const spreadAngle = weaponProperties.shotgun.spreadAngle;
        
        for (let i = 0; i < pelletCount; i++) {
            const angleOffset = (i - pelletCount/2) * spreadAngle / pelletCount;
            bullets.push({
                x: player.x,
                y: player.y,
                angle: player.angle + angleOffset,
                speed: weaponProperties.shotgun.bulletSpeed,
                size: 3,
                distance: 0,
                maxDistance: weaponProperties.shotgun.bulletRange,
                bounces: weaponProperties.shotgun.bounces,
                damage: weaponProperties.shotgun.damage,
                weapon: 'shotgun',
                canPassThroughWalls: false
            });
        }
        
        createParticles(player.x, player.y, weaponProperties.shotgun.color, 10, 3);
        soundManager.play('shotgun');
    }
    
    function shootSniper() {
        bullets.push({
            x: player.x,
            y: player.y,
            angle: player.angle,
            speed: weaponProperties.sniper.bulletSpeed,
            size: 6,
            distance: 0,
            maxDistance: weaponProperties.sniper.bulletRange,
            bounces: weaponProperties.sniper.bounces,
            damage: weaponProperties.sniper.damage,
            weapon: 'sniper',
            canPassThroughWalls: true
        });
        
        createParticles(player.x, player.y, weaponProperties.sniper.color, 8, 4);
        shakeScreen(5);
        soundManager.play('sniper');
    }
    
    function enemyShoot(enemy) {
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        
        bullets.push({
            x: enemy.x,
            y: enemy.y,
            angle: angle,
            speed: enemy.bulletSpeed,
            size: 5,
            distance: 0,
            maxDistance: 1000,
            bounces: 0,
            damage: enemy.attackDamage,
            weapon: 'enemy',
            canPassThroughWalls: enemy.canShootThroughWalls,
            isEnemyBullet: true
        });
        
        createParticles(enemy.x, enemy.y, '#ff0000', 5, 2);
        soundManager.play('pistol', 0.7);
    }
    
    function enemyAttack(enemy) {
        if (!player.invulnerable && !player.isDead) {
            player.health -= enemy.attackDamage;
            player.invulnerable = true;
            player.invulnerableTime = 60;
            createBloodSplatter(player.x, player.y, 5);
            shakeScreen(10);
            updateHUD();
            soundManager.play('enemyHit');
            
            if (player.health <= 0) {
                playerDeath();
            }
        }
        
        createParticles(enemy.x, enemy.y, '#ff0000', 10, 4);
    }
    
    function playerDeath() {
        player.isDead = true;
        createBloodSplatter(player.x, player.y, 20);
        shakeScreen(20);
    }
    
    function createBloodSplatter(x, y, intensity) {
        for (let i = 0; i < intensity * 5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 50;
            const splatterX = x + Math.cos(angle) * distance;
            const splatterY = y + Math.sin(angle) * distance;
            const size = Math.random() * 10 + 5;
            
            bloodSplatters.push({
                x: splatterX,
                y: splatterY,
                size: size,
                color: `rgba(${150 + Math.random() * 50}, 0, 0, ${0.5 + Math.random() * 0.5})`
            });
        }
        
        createParticles(x, y, '#ff0000', intensity * 10, 5);
    }
    
    function createParticles(x, y, color, count, speed) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * 3 + 1,
                color: color,
                life: 30
            });
        }
    }
    
    function playerKick() {
        player.isKicking = true;
        
        const kickDistance = 50;
        const kickX = player.x + Math.cos(player.angle) * kickDistance;
        const kickY = player.y + Math.sin(player.angle) * kickDistance;
        
        createParticles(kickX, kickY, '#ffffff', 10, 3);
        
        for (const door of doors) {
            if (!door.isBroken &&
                kickX > door.x && 
                kickX < door.x + door.width &&
                kickY > door.y && 
                kickY < door.y + door.height) {
                
                door.health--;
                createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 15, 4);
                
                if (door.health <= 0) {
                    door.isBroken = true;
                    createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                    shakeScreen(10);
                    soundManager.play('doorBreak');
                }
                
                break;
            }
        }
        
        setTimeout(() => {
            player.isKicking = false;
        }, 200);
    }
    
    function updateHUD() {
        const killCountElement = document.getElementById('killCount');
        const comboCountElement = document.getElementById('comboCount');
        const healthElement = document.getElementById('healthCount');
        const scoreElement = document.getElementById('scoreCount');
        
        if (killCountElement) killCountElement.textContent = kills;
        if (comboCountElement) comboCountElement.textContent = combo;
        if (healthElement) healthElement.textContent = player.health;
        if (scoreElement) scoreElement.textContent = score;
    }
    
    function resetGame() {
        kills = 0;
        combo = 0;
        score = 0;
        player.health = player.maxHealth;
        player.pistolAmmo = weaponProperties.pistol.maxAmmo;
        player.shotgunAmmo = weaponProperties.shotgun.maxAmmo;
        player.sniperAmmo = weaponProperties.sniper.maxAmmo;
        player.isReloading = false;
        player.isShotgunCocked = true;
        player.isSniperReady = true;
        player.isDead = false;
        levelComplete = false;
        levelStartTime = Date.now();
        floatingTexts = [];
        
        // Reset camera position
        camera.x = 0;
        camera.y = 0;
        
        // Reset achievements
        for (const achievement of achievements) {
            if (achievement.id !== 'bossSlayer') {
                achievement.unlocked = false;
            }
        }
        
        initLevel();
        updateHUD();
    }
    
    // ========== DRAWING FUNCTIONS ==========
    function drawWalls() {
        for (const wall of walls) {
            if (wall.x + wall.width > camera.x && 
                wall.x < camera.x + camera.width &&
                wall.y + wall.height > camera.y && 
                wall.y < camera.y + camera.height) {
                
                ctx.fillStyle = '#774400';
                ctx.fillRect(wall.x - camera.x, wall.y - camera.y, wall.width, wall.height);
                
                ctx.strokeStyle = '#553300';
                ctx.lineWidth = 1;
                
                for (let j = 0; j < wall.height; j += 15) {
                    ctx.beginPath();
                    ctx.moveTo(wall.x - camera.x, wall.y + j - camera.y);
                    ctx.lineTo(wall.x + wall.width - camera.x, wall.y + j - camera.y);
                    ctx.stroke();
                }
                
                for (let i = 0; i < wall.width; i += 30) {
                    for (let j = 0; j < wall.height; j += 30) {
                        ctx.beginPath();
                        ctx.moveTo(wall.x + i - camera.x, wall.y + j - camera.y);
                        ctx.lineTo(wall.x + i - camera.x, wall.y + j + 15 - camera.y);
                        ctx.stroke();
                    }
                }
                
                ctx.fillStyle = '#885500';
                for (let i = 0; i < 3; i++) {
                    const peelX = wall.x + Math.random() * wall.width;
                    const peelY = wall.y + Math.random() * wall.height;
                    const peelWidth = Math.random() * 20 + 10;
                    const peelHeight = Math.random() * 5 + 2;
                    
                    ctx.fillRect(peelX - camera.x, peelY - camera.y, peelWidth, peelHeight);
                }
                
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(wall.x - camera.x, wall.y - camera.y, wall.width, wall.height);
            }
        }
    }
    
    function drawDoors() {
        for (const door of doors) {
            if (door.x + door.width > camera.x && 
                door.x < camera.x + camera.width &&
                door.y + door.height > camera.y && 
                door.y < camera.y + camera.height) {
                
                if (!door.isBroken) {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(door.x - camera.x, door.y - camera.y, door.width, door.height);
                    
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 1;
                    
                    for (let i = 5; i < door.width; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(door.x + i - camera.x, door.y - camera.y);
                        ctx.lineTo(door.x + i - camera.x, door.y + door.height - camera.y);
                        ctx.stroke();
                    }
                    
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(door.x - camera.x, door.y - camera.y, door.width, door.height);
                    
                    if (door.health < door.maxHealth) {
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 1;
                        const crackCount = door.maxHealth - door.health;
                        
                        for (let i = 0; i < crackCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(
                                door.x + Math.random() * door.width - camera.x,
                                door.y + Math.random() * door.height - camera.y
                            );
                            ctx.lineTo(
                                door.x + Math.random() * door.width - camera.x,
                                door.y + Math.random() * door.height - camera.y
                            );
                            ctx.stroke();
                        }
                    }
                } else {
                    ctx.fillStyle = '#8B4513';
                    
                    for (let i = 0; i < 8; i++) {
                        const fragmentX = door.x + Math.random() * door.width;
                        const fragmentY = door.y + Math.random() * door.height;
                        const fragmentWidth = Math.random() * 15 + 5;
                        const fragmentHeight = Math.random() * 15 + 5;
                        
                        ctx.save();
                        ctx.translate(fragmentX - camera.x, fragmentY - camera.y);
                        ctx.rotate(Math.random() * Math.PI);
                        ctx.fillRect(-fragmentWidth/2, -fragmentHeight/2, fragmentWidth, fragmentHeight);
                        ctx.restore();
                    }
                }
            }
        }
    }
    
    function drawBloodSplatters() {
        for (const splatter of bloodSplatters) {
            if (splatter.x > camera.x && 
                splatter.x < camera.x + camera.width &&
                splatter.y > camera.y && 
                splatter.y < camera.y + camera.height) {
                
                ctx.fillStyle = splatter.color;
                ctx.beginPath();
                ctx.arc(splatter.x - camera.x, splatter.y - camera.y, splatter.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    function drawPlayer() {
        ctx.save();
        ctx.translate(player.x - camera.x, player.y - camera.y);
        ctx.rotate(player.angle);
        
        ctx.fillStyle = player.invulnerable && Math.floor(player.invulnerableTime / 5) % 2 === 0 ? '#ffffff' : '#00ffff';
        ctx.beginPath();
        ctx.arc(0, 0, player.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(player.size + 5, 0);
        ctx.stroke();
        
        if (player.isKicking) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(player.size + 5, 0);
            ctx.lineTo(player.size + 15, -5);
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    function drawBullets() {
        for (const bullet of bullets) {
            if (bullet.weapon === 'pistol') {
                ctx.fillStyle = weaponProperties.pistol.color;
            } else if (bullet.weapon === 'shotgun') {
                ctx.fillStyle = weaponProperties.shotgun.color;
            } else if (bullet.weapon === 'sniper') {
                ctx.fillStyle = weaponProperties.sniper.color;
            } else {
                ctx.fillStyle = '#ff0000';
            }
            
            ctx.beginPath();
            ctx.arc(bullet.x - camera.x, bullet.y - camera.y, bullet.size, 0, Math.PI * 2);
            ctx.fill();
            
            if (bullet.weapon === 'pistol') {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            } else if (bullet.weapon === 'shotgun') {
                ctx.strokeStyle = 'rgba(255, 153, 0, 0.5)';
            } else if (bullet.weapon === 'sniper') {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
            } else {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            }
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bullet.x - camera.x, bullet.y - camera.y);
            ctx.lineTo(
                bullet.x - Math.cos(bullet.angle) * 15 - camera.x,
                bullet.y - Math.sin(bullet.angle) * 15 - camera.y
            );
            ctx.stroke();
        }
    }
    
    function drawEnemies() {
        for (const enemy of enemies) {
            ctx.fillStyle = enemy.color;
            
            if (enemy.type === 'basic') {
                ctx.fillRect(
                    enemy.x - enemy.size - camera.x, 
                    enemy.y - enemy.size - camera.y, 
                    enemy.size * 2, 
                    enemy.size * 2
                );
            } else if (enemy.type === 'sniper') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(-enemy.size, -enemy.size);
                ctx.lineTo(-enemy.size, enemy.size);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            } else if (enemy.type === 'heavy') {
                ctx.beginPath();
                ctx.arc(enemy.x - camera.x, enemy.y - camera.y, enemy.size, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'shield') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = i / 6 * Math.PI * 2;
                    const x = Math.cos(angle) * enemy.size;
                    const y = Math.sin(angle) * enemy.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                if (enemy.hasShield) {
                    ctx.strokeStyle = '#0099ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            } else if (enemy.type === 'suicide') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    const radius = i % 2 === 0 ? enemy.size : enemy.size / 2;
                    const angle = i / 10 * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                // Draw flash if needed
                if (enemy.shouldFlash) {
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(enemy.x - camera.x, enemy.y - camera.y, enemy.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (enemy.type === 'spawner') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = i / 5 * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * enemy.size;
                    const y = Math.sin(angle) * enemy.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, enemy.size / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(
                enemy.x - enemy.size - camera.x, 
                enemy.y - enemy.size - 15 - camera.y, 
                enemy.size * 2, 
                5
            );
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(
                enemy.x - enemy.size - camera.x, 
                enemy.y - enemy.size - 15 - camera.y, 
                enemy.size * 2 * healthPercent, 
                5
            );
            
            if (enemy.hasKnife) {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(enemy.size + 10, 0);
                ctx.stroke();
                
                ctx.restore();
            } else if (enemy.type === 'sniper') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(enemy.size + 20, 0);
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Draw path for debugging (optional)
            if (enemy.path && enemy.path.length > 0) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(enemy.x - camera.x, enemy.y - camera.y);
                
                for (let i = enemy.pathIndex; i < enemy.path.length; i++) {
                    const point = enemy.path[i];
                    ctx.lineTo(point.x - camera.x, point.y - camera.y);
                }
                
                ctx.stroke();
            }
        }
    }
    
    function drawParticles() {
        for (const p of particles) {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 30;
            ctx.beginPath();
            ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
    
    function drawFloatingTexts() {
        for (const text of floatingTexts) {
            text.draw(ctx);
        }
    }
    
    function drawHUD() {
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        
        ctx.fillText(`Score: ${score}`, 20, canvas.height - 160);
        
        let weaponText = `Weapon: ${player.currentWeapon === 'pistol' ? 'Pistol' : player.currentWeapon === 'shotgun' ? 'Shotgun' : 'Sniper'}`;
        ctx.fillText(weaponText, 20, canvas.height - 140);
        
        if (player.currentWeapon === 'pistol') {
            let ammoText = `Ammo: ${player.pistolAmmo}/${weaponProperties.pistol.maxAmmo}`;
            if (player.isReloading) {
                ammoText += ` (Reloading...)`;
            }
            ctx.fillText(ammoText, 20, canvas.height - 120);
        } else if (player.currentWeapon === 'shotgun') {
            let ammoText = `Ammo: ${player.shotgunAmmo}/${weaponProperties.shotgun.maxAmmo}`;
            if (player.isReloading) {
                ammoText += ` (Reloading...)`;
            } else if (!player.isShotgunCocked) {
                ammoText += ` (Needs Cocking - Press C)`;
            }
            ctx.fillText(ammoText, 20, canvas.height - 120);
        } else if (player.currentWeapon === 'sniper') {
            let ammoText = `Ammo: ${player.sniperAmmo}/${weaponProperties.sniper.maxAmmo}`;
            if (player.isReloading) {
                ammoText += ` (Reloading...)`;
            } else if (!player.isSniperReady) {
                ammoText += ` (Needs Ready - Press V)`;
            }
            ctx.fillText(ammoText, 20, canvas.height - 120);
        }
        
        ctx.fillText(`Health: ${player.health}/${player.maxHealth}`, 20, canvas.height - 100);
        
        ctx.fillText('1: Pistol  2: Shotgun  3: Sniper', 20, canvas.height - 80);
        ctx.fillText('F: Kick doors  R: Reload', 20, canvas.height - 60);
        ctx.fillText('C: Cock shotgun  V: Ready sniper', 20, canvas.height - 40);
        ctx.fillText('WASD: Move  Mouse: Aim & Shoot', 20, canvas.height - 20);
        
        ctx.textAlign = 'right';
        ctx.fillStyle = enemyTypes.basic.color;
        ctx.fillText('Basic Enemy (10 HP)', canvas.width - 20, canvas.height - 140);
        ctx.fillStyle = enemyTypes.sniper.color;
        ctx.fillText('Sniper Enemy (25 HP)', canvas.width - 20, canvas.height - 120);
        ctx.fillStyle = enemyTypes.heavy.color;
        ctx.fillText('Heavy Enemy (40 HP)', canvas.width - 20, canvas.height - 100);
        ctx.fillStyle = enemyTypes.shield.color;
        ctx.fillText('Shield Enemy (30 HP)', canvas.width - 20, canvas.height - 80);
        ctx.fillStyle = enemyTypes.suicide.color;
        ctx.fillText('Suicide Enemy (15 HP)', canvas.width - 20, canvas.height - 60);
        ctx.fillStyle = enemyTypes.spawner.color;
        ctx.fillText('Spawner Enemy (50 HP)', canvas.width - 20, canvas.height - 40);
        
        ctx.fillStyle = '#ffffff';
        ctx.fillText(`Kills: ${kills}`, canvas.width - 20, canvas.height - 20);
        ctx.fillText(`Combo: ${combo}`, canvas.width - 20, canvas.height - 5);
        ctx.fillText(`Sound: ${soundManager.enabled ? 'ON' : 'OFF'} (M to toggle)`, canvas.width - 20, canvas.height - 180);
        ctx.fillText('Achievements (TAB)', canvas.width - 20, canvas.height - 160);
    }
    
    function drawAchievementNotification() {
        if (showAchievement) {
            const alpha = Math.min(1, achievementTimer / 60);
            
            ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * alpha})`;
            ctx.fillRect(canvas.width / 2 - 200, 100, 400, 80);
            
            ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(canvas.width / 2 - 200, 100, 400, 80);
            
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('ACHIEVEMENT UNLOCKED!', canvas.width / 2, 130);
            
            ctx.font = '16px Courier New';
            ctx.fillText(showAchievement.name, canvas.width / 2, 155);
            
            ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
            ctx.font = '24px Courier New';
            ctx.fillText('', canvas.width / 2 - 180, 140);
        }
    }
    
    function drawAchievementsScreen() {
        if (keys['tab']) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('ACHIEVEMENTS', canvas.width / 2, 50);
            
            ctx.font = '20px Courier New';
            ctx.textAlign = 'left';
            
            let y = 120;
            for (const achievement of achievements) {
                if (achievement.unlocked) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(` ${achievement.name}`, 200, y);
                } else {
                    ctx.fillStyle = '#888888';
                    ctx.fillText(`? ${achievement.name}`, 200, y);
                }
                
                ctx.fillStyle = '#cccccc';
                ctx.font = '16px Courier New';
                ctx.fillText(achievement.description, 220, y + 25);
                
                y += 70;
                ctx.font = '20px Courier New';
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText('Press TAB to close', canvas.width / 2, canvas.height - 50);
        }
    }
    
    // ========== MAIN GAME LOOP ==========
    function gameLoop() {
        ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        
        if (camera.shakeIntensity > 0) {
            ctx.translate(
                (Math.random() - 0.5) * camera.shakeIntensity,
                (Math.random() - 0.5) * camera.shakeIntensity
            );
            camera.shakeIntensity *= 0.9;
        }
        
        updatePlayer();
        updateCamera();
        updateEnemies();
        updateBullets();
        updateParticles();
        updateFloatingTexts();
        
        if (exitPortal) {
            exitPortal.update();
            if (exitPortal.checkCollision(player) && enemies.length === 0 && !boss) {
                levelComplete = true;
                soundManager.play('portal');
            }
        }
        
        if (boss) {
            boss.update();
        }
        
        if (showAchievement) {
            achievementTimer--;
            if (achievementTimer <= 0) {
                showAchievement = null;
            }
        }
        
        checkAchievements();
        
        drawBloodSplatters();
        drawWalls();
        drawDoors();
        drawEnemies();
        drawPlayer();
        drawBullets();
        drawParticles();
        drawFloatingTexts();
        
        if (exitPortal) {
            exitPortal.draw(ctx);
        }
        
        if (boss) {
            boss.draw(ctx);
        }
        
        drawHUD();
        drawAchievementNotification();
        drawAchievementsScreen();
        
        ctx.restore();
        
        if (levelComplete) {
            ctx.fillStyle = '#00ff00';
            ctx.font = '48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('LEVEL COMPLETE!', canvas.width/2, canvas.height/2);
            ctx.font = '24px Courier New';
            ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 50);
            ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 100);
            
            if (keys['r']) {
                resetGame();
            }
        }
        
        if (player.isDead) {
            ctx.fillStyle = '#ff0000';
            ctx.font = '48px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
            ctx.font = '24px Courier New';
            ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 50);
            
            if (keys['r']) {
                resetGame();
            }
        }
        
        requestAnimationFrame(gameLoop);
    }
    
    // ========== START THE GAME ==========
    initLevel();
    loadSounds();
    updateHUD();
    gameLoop();
});