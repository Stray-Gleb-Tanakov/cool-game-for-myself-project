// Wait for the DOM to be fully loaded before running the game
document.addEventListener('DOMContentLoaded', function() {
    // ========== GAME SETUP ==========
    // Get canvas element and set up rendering context
    const canvas = document.getElementById('gameCanvas');
    
    // Check if canvas exists
    if (!canvas) {
        console.error('Canvas element not found!');
        return;
    }
    
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions - these are the visible area
    canvas.width = 1200; 
    canvas.height = 900;
    
    // Game world dimensions - larger than visible area for scrolling
    const worldWidth = 7200; 
    const worldHeight = 4000;
    
    // ========== WEAPON PROPERTIES ==========
    const weaponProperties = {
        pistol: {
            damage: 10,
            maxAmmo: 12,
            reloadTime: 60,
            fireRate: 15,
            bulletSpeed: 15,
            bulletRange: 500,
            bounces: 3,
            color: '#ffff00',
            knockback: 2
        },
        shotgun: {
            damage: 5,
            maxAmmo: 2,
            reloadTime: 90,
            fireRate: 30,
            bulletSpeed: 12,
            bulletRange: 300,
            bounces: 1,
            pelletCount: 10,
            spreadAngle: Math.PI / 6,
            color: '#ff9900',
            knockback: 5
        },
        sniper: {
            damage: 25,
            maxAmmo: 5,
            reloadTime: 120,
            fireRate: 45,
            bulletSpeed: 25,
            bulletRange: 1000,
            bounces: 0,
            color: '#00ffff',
            canPassThroughWalls: true,
            knockback: 8
        },
        melee: {
            damage: 30,
            maxAmmo: -1, // Unlimited
            reloadTime: 0,
            fireRate: 30,
            bulletSpeed: 0,
            bulletRange: 30,
            bounces: 0,
            color: '#ffffff',
            knockback: 3
        }
    };
    
    // ========== ENEMY TYPES ==========
    const enemyTypes = {
        basic: {
            health: 10,
            maxHealth: 10,
            speed: 0.7,
            size: 15,
            color: '#ff00ff',
            hasKnife: true,
            attackDamage: 10,
            attackRange: 30,
            detectionRange: 800,
            points: 100,
            ammoDrop: { chance: 0.3, count: 3 }
        },
        sniper: {
            health: 25,
            maxHealth: 25,
            speed: 0.5,
            size: 20,
            color: '#00ff00',
            hasKnife: false,
            attackDamage: 15,
            attackRange: 1000,
            detectionRange: 1200,
            fireRate: 90,
            canShootThroughWalls: false,
            bulletSpeed: 6,
            points: 250,
            ammoDrop: { chance: 0.5, count: 5 }
        },
        heavy: {
            health: 40,
            maxHealth: 40,
            speed: 0.4,
            size: 25,
            color: '#ff0000',
            hasKnife: true,
            attackDamage: 20,
            attackRange: 30,
            detectionRange: 600,
            points: 500,
            ammoDrop: { chance: 0.7, count: 7 }
        },
        shield: {
            health: 30,
            maxHealth: 30,
            speed: 0.5,
            size: 20,
            color: '#0099ff',
            hasKnife: true,
            attackDamage: 15,
            attackRange: 30,
            detectionRange: 800,
            hasShield: true,
            shieldHealth: 20,
            shieldMaxHealth: 20,
            points: 400,
            ammoDrop: { chance: 0.6, count: 6 }
        },
        suicide: {
            health: 15,
            maxHealth: 15,
            speed: 1.5,
            size: 15,
            color: '#ff9900',
            hasKnife: false,
            attackDamage: 50,
            attackRange: 40,
            detectionRange: 1000,
            explosionRadius: 100,
            explodesOnDeath: true,
            flashRate: 5,
            points: 300,
            ammoDrop: { chance: 0.4, count: 4 }
        },
        spawner: {
            health: 50,
            maxHealth: 50,
            speed: 0.3,
            size: 25,
            color: '#9933ff',
            hasKnife: false,
            attackDamage: 10,
            attackRange: 800,
            detectionRange: 1200,
            canSpawn: true,
            spawnCooldown: 180,
            spawnRadius: 150,
            points: 750,
            ammoDrop: { chance: 0.8, count: 8 }
        },
        // New enemy types
        hacker: {
            health: 20,
            maxHealth: 20,
            speed: 0.6,
            size: 18,
            color: '#00ff88',
            hasKnife: false,
            attackDamage: 5,
            attackRange: 300,
            detectionRange: 900,
            canHack: true,
            hackCooldown: 180,
            hackDuration: 120,
            points: 350,
            ammoDrop: { chance: 0.6, count: 6 }
        },
        cloaker: {
            health: 15,
            maxHealth: 15,
            speed: 0.9,
            size: 16,
            color: '#aa00ff',
            hasKnife: true,
            attackDamage: 25,
            attackRange: 25,
            detectionRange: 700,
            canCloak: true,
            cloakCooldown: 150,
            cloakDuration: 180,
            points: 400,
            ammoDrop: { chance: 0.5, count: 5 }
        },
        fire: {
            health: 30,
            maxHealth: 30,
            speed: 0.6,
            size: 20,
            color: '#ff5500',
            hasKnife: false,
            attackDamage: 8,
            attackRange: 250,
            detectionRange: 850,
            canBurn: true,
            burnCooldown: 150,
            burnDamage: 2,
            burnDuration: 60,
            points: 350,
            ammoDrop: { chance: 0.5, count: 5 }
        },
        electric: {
            health: 25,
            maxHealth: 25,
            speed: 0.8,
            size: 19,
            color: '#ffff00',
            hasKnife: false,
            attackDamage: 12,
            attackRange: 300,
            detectionRange: 950,
            canShock: true,
            shockCooldown: 100,
            shockDamage: 5,
            shockRadius: 80,
            points: 450,
            ammoDrop: { chance: 0.6, count: 6 }
        }
    };
    
    // ========== POWER-UP TYPES ==========
    const powerUpTypes = {
        health: {
            color: '#ff0000',
            symbol: '+',
            size: 15,
            effect: 'health',
            value: 25,
            duration: 0
        },
        speed: {
            color: '#00ff00',
            symbol: '¬ª',
            size: 15,
            effect: 'speed',
            value: 1.5,
            duration: 300
        },
        rapidFire: {
            color: '#ffff00',
            symbol: '‚ö°',
            size: 15,
            effect: 'rapidFire',
            value: 0.5,
            duration: 300
        },
        damage: {
            color: '#ff00ff',
            symbol: '‚öî',
            size: 15,
            effect: 'damage',
            value: 2,
            duration: 300
        },
        invulnerability: {
            color: '#00ffff',
            symbol: 'üõ°',
            size: 15,
            effect: 'invulnerability',
            value: 1,
            duration: 180
        },
        ammo: {
            color: '#ffffff',
            symbol: '‚óâ',
            size: 15,
            effect: 'ammo',
            value: 1,
            duration: 0
        }
    };
    
    // ========== AMMO TYPES ==========
    const ammoTypes = {
        pistol: {
            color: '#ffff00',
            symbol: '‚óè',
            size: 10,
            value: 3
        },
        shotgun: {
            color: '#ff9900',
            symbol: '‚óè',
            size: 12,
            value: 1
        },
        sniper: {
            color: '#00ffff',
            symbol: '‚óè',
            size: 14,
            value: 2
        }
    };
    
    // ========== KILL NOTIFICATIONS ==========
    const killNotifications = [
        { text: 'BRUTAL', color: '#ff0000', threshold: 1 },
        { text: 'COOL', color: '#00ffff', threshold: 2 },
        { text: 'SHAMEFUL', color: '#ff00ff', threshold: 3 },
        { text: 'HARDCORE', color: '#ff5500', threshold: 4 },
        { text: 'PERFECT', color: '#00ff00', threshold: 5 },
        { text: 'INSANE', color: '#ff0088', threshold: 6 },
        { text: 'HEADSHOT', color: '#ffff00', threshold: 7, special: 'headshot' },
        { text: 'MEGA KILL', color: '#ff00ff', threshold: 8 },
        { text: 'ULTRA VIOLENCE', color: '#8800ff', threshold: 9 },
        { text: 'GODLIKE', color: '#ffffff', threshold: 10 }
    ];
    
    // ========== ROOM SYSTEM ==========
    const roomStates = {
        LOCKED: 'locked',
        UNLOCKED: 'unlocked',
        CLEARED: 'cleared'
    };
    
    // ========== CAMERA SYSTEM ==========
    const camera = {
        x: 0,
        y: 0,
        width: canvas.width,
        height: canvas.height,
        followSpeed: 0.1,
        shakeIntensity: 0,
        flashIntensity: 0,
        glitchIntensity: 0,
        chromaticAberration: 0,
        vhsLines: false
    };
    
    // ========== PLAYER OBJECT ==========
    let player = {
        size: 15,
        speed: 3,
        angle: 0,
        health: 100,
        maxHealth: 100,
        isShooting: false,
        shootCooldown: 0,
        currentWeapon: 'pistol',
        pistolAmmo: 12,
        shotgunAmmo: 2,
        sniperAmmo: 5,
        isReloading: false,
        reloadTime: 0,
        pistolSemiAuto: true,
        isShotgunCocked: true,
        isSniperReady: true,
        isKicking: false,
        kickCooldown: 0,
        invulnerable: false,
        invulnerableTime: 0,
        isDead: false,
        // Power-up effects
        speedMultiplier: 1,
        fireRateMultiplier: 1,
        damageMultiplier: 1,
        powerUpTimers: {
            speed: 0,
            rapidFire: 0,
            damage: 0,
            invulnerability: 0
        },
        // Status effects
        isFrozen: false,
        frozenTime: 0,
        isBurning: false,
        burnTime: 0,
        burnDamageTimer: 0,
        isShocked: false,
        shockedTime: 0,
        isHacked: false,
        hackedTime: 0,
        // Visual effects
        recoilAngle: 0,
        muzzleFlash: 0,
        // Execution
        canExecute: false,
        isExecuting: false,
        executionTarget: null
    };
    
    // ========== GAME OBJECTS ==========
    let bullets = [];
    let enemies = [];
    let walls = [];
    let doors = [];
    let rooms = [];
    let currentRoom = null;
    let particles = [];
    let bloodSplatters = [];
    let floatingTexts = [];
    let exitPortal = null;
    let boss = null;
    let powerUps = [];
    let ammoDrops = [];
    let kills = 0;
    let combo = 0;
    lastKillTime = 0;
    let score = 0;
    let levelComplete = false;
    let levelStartTime = Date.now();
    let explosions = []; // Track active explosions
    let wallDecals = []; // Bullet marks on walls
    let bulletTrails = []; // Visual trails for bullets
    let killStreak = 0;
    let headshotKills = 0;
    let executionKills = 0;
    
    // ========== ENEMY SPAWNING SYSTEM ==========
    let enemySpawnTimer = 0;
    let enemySpawnInterval = 300; // Spawn every 5 seconds at 60fps
    let maxEnemies = 30;
    let spawnPoints = []; // Will store valid spawn locations
    let difficultyLevel = 1;
    
    // ========== QUADTREE PATHFINDING ==========
    class QuadTreeNode {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.children = [];
            this.isLeaf = true;
            this.walkable = true;
            this.neighbors = [];
            this.id = `${x},${y},${width},${height}`;
        }
        
        subdivide() {
            if (this.width < 60 || this.height < 60) return;
            
            const halfWidth = this.width / 2;
            const halfHeight = this.height / 2;
            
            // Create four children
            this.children.push(new QuadTreeNode(this.x, this.y, halfWidth, halfHeight));
            this.children.push(new QuadTreeNode(this.x + halfWidth, this.y, halfWidth, halfHeight));
            this.children.push(new QuadTreeNode(this.x, this.y + halfHeight, halfWidth, halfHeight));
            this.children.push(new QuadTreeNode(this.x + halfWidth, this.y + halfHeight, halfWidth, halfHeight));
            
            this.isLeaf = false;
        }
        
        contains(x, y) {
            return x >= this.x && x < this.x + this.width &&
                   y >= this.y && y < this.y + this.height;
        }
        
        intersects(rect) {
            return !(rect.x + rect.width < this.x || 
                     rect.x > this.x + this.width ||
                     rect.y + rect.height < this.y || 
                     rect.y > this.y + this.height);
        }
    }
    
    class QuadTree {
        constructor(worldWidth, worldHeight) {
            this.root = new QuadTreeNode(0, 0, worldWidth, worldHeight);
            this.leafNodes = [];
            this.nodeMap = new Map();
        }
        
        buildTree(walls, doors) {
            this._subdivideRecursive(this.root, walls, doors);
            this._collectLeafNodes(this.root);
            this._buildNeighborGraph();
        }
        
        _subdivideRecursive(node, walls, doors) {
            // Check if node contains obstacles
            let hasObstacle = false;
            
            for (const wall of walls) {
                if (node.intersects(wall)) {
                    hasObstacle = true;
                    break;
                }
            }
            
            if (!hasObstacle) {
                for (const door of doors) {
                    if (!door.isBroken && node.intersects(door)) {
                        hasObstacle = true;
                        break;
                    }
                }
            }
            
            // If node has obstacles and is large enough, subdivide
            if (hasObstacle && node.width >= 60 && node.height >= 60) {
                node.subdivide();
                
                for (const child of node.children) {
                    this._subdivideRecursive(child, walls, doors);
                }
            } else {
                // Mark as walkable if no obstacles
                node.walkable = !hasObstacle;
            }
        }
        
        _collectLeafNodes(node) {
            if (node.isLeaf) {
                if (node.walkable) {
                    this.leafNodes.push(node);
                    this.nodeMap.set(node.id, node);
                }
            } else {
                for (const child of node.children) {
                    this._collectLeafNodes(child);
                }
            }
        }
        
        _buildNeighborGraph() {
            // For each leaf node, find adjacent leaf nodes
            for (const node of this.leafNodes) {
                node.neighbors = []; // Clear existing neighbors
                
                // Check all other leaf nodes for adjacency
                for (const other of this.leafNodes) {
                    if (node === other) continue;
                    
                    // Check if nodes are adjacent (including diagonals)
                    if (this._areNodesAdjacent(node, other)) {
                        node.neighbors.push(other);
                    }
                }
            }
        }
        
        _areNodesAdjacent(node1, node2) {
            // Check if two nodes share an edge or corner
            const margin = 5; // Small margin for floating point precision
            
            // Right edge of node1 touches left edge of node2
            if (Math.abs(node1.x + node1.width - node2.x) < margin &&
                !(node1.y + node1.height < node2.y + margin || node1.y > node2.y + node2.height - margin)) {
                return true;
            }
            
            // Left edge of node1 touches right edge of node2
            if (Math.abs(node1.x - (node2.x + node2.width)) < margin &&
                !(node1.y + node1.height < node2.y + margin || node1.y > node2.y + node2.height - margin)) {
                return true;
            }
            
            // Bottom edge of node1 touches top edge of node2
            if (Math.abs(node1.y + node1.height - node2.y) < margin &&
                !(node1.x + node1.width < node2.x + margin || node1.x > node2.x + node2.width - margin)) {
                return true;
            }
            
            // Top edge of node1 touches bottom edge of node2
            if (Math.abs(node1.y - (node2.y + node2.height)) < margin &&
                !(node1.x + node1.width < node2.x + margin || node1.x > node2.x + node2.width - margin)) {
                return true;
            }
            
            // Check corners (diagonal adjacency)
            if ((Math.abs(node1.x + node1.width - node2.x) < margin && 
                 Math.abs(node1.y + node1.height - node2.y) < margin) ||
                (Math.abs(node1.x - (node2.x + node2.width)) < margin && 
                 Math.abs(node1.y + node1.height - node2.y) < margin) ||
                (Math.abs(node1.x + node1.width - node2.x) < margin && 
                 Math.abs(node1.y - (node2.y + node2.height)) < margin) ||
                (Math.abs(node1.x - (node2.x + node2.width)) < margin && 
                 Math.abs(node1.y - (node2.y + node2.height)) < margin)) {
                return true;
            }
            
            return false;
        }
        
        findNode(x, y) {
            return this._findNodeRecursive(this.root, x, y);
        }
        
        _findNodeRecursive(node, x, y) {
            if (node.isLeaf) {
                return node;
            }
            
            for (const child of node.children) {
                if (child.contains(x, y)) {
                    return this._findNodeRecursive(child, x, y);
                }
            }
            
            return null;
        }
        
        findPath(startX, startY, endX, endY) {
            try {
                const startNode = this.findNode(startX, startY);
                const endNode = this.findNode(endX, endY);
                
                if (!startNode || !endNode || !startNode.walkable || !endNode.walkable) {
                    return null;
                }
                
                // Use A* to find path through nodes
                return this._aStar(startNode, endNode);
            } catch (error) {
                console.error("Error in findPath:", error);
                return null;
            }
        }
        
        _aStar(startNode, endNode) {
            const openSet = [startNode];
            const closedSet = [];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();
            
            gScore.set(startNode, 0);
            fScore.set(startNode, this._heuristic(startNode, endNode));
            
            while (openSet.length > 0) {
                // Find node with lowest fScore
                let current = openSet[0];
                let currentIndex = 0;
                
                for (let i = 1; i < openSet.length; i++) {
                    if (fScore.get(openSet[i]) < fScore.get(current)) {
                        current = openSet[i];
                        currentIndex = i;
                    }
                }
                
                // Check if we've reached the goal
                if (current === endNode) {
                    return this._reconstructPath(cameFrom, current);
                }
                
                // Move current from openSet to closedSet
                openSet.splice(currentIndex, 1);
                closedSet.push(current);
                
                // Check all neighbors
                for (const neighbor of current.neighbors) {
                    if (closedSet.includes(neighbor)) {
                        continue;
                    }
                    
                    // Calculate tentative gScore
                    const tentativeGScore = gScore.get(current) + this._distance(current, neighbor);
                    
                    if (!openSet.includes(neighbor)) {
                        openSet.push(neighbor);
                    } else if (tentativeGScore >= gScore.get(neighbor)) {
                        continue; // This is not a better path
                    }
                    
                    // This path is the best until now
                    cameFrom.set(neighbor, current);
                    gScore.set(neighbor, tentativeGScore);
                    fScore.set(neighbor, tentativeGScore + this._heuristic(neighbor, endNode));
                }
            }
            
            return null; // No path found
        }
        
        _heuristic(node1, node2) {
            // Euclidean distance between centers of nodes
            const dx = (node1.x + node1.width/2) - (node2.x + node2.width/2);
            const dy = (node1.y + node1.height/2) - (node2.y + node2.height/2);
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        _distance(node1, node2) {
            // Distance between centers of nodes
            const dx = (node1.x + node1.width/2) - (node2.x + node2.width/2);
            const dy = (node1.y + node1.height/2) - (node2.y + node2.height/2);
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        _reconstructPath(cameFrom, current) {
            const path = [current];
            
            while (cameFrom.has(current)) {
                current = cameFrom.get(current);
                path.unshift(current);
            }
            
            // Convert nodes to world coordinates (center of each node)
            return path.map(node => ({
                x: node.x + node.width / 2,
                y: node.y + node.height / 2
            }));
        }
        
        updateObstacles(walls, doors) {
            try {
                // Clear existing data
                this.leafNodes = [];
                this.nodeMap.clear();
                
                // Rebuild tree with updated obstacles
                this.buildTree(walls, doors);
            } catch (error) {
                console.error("Error updating obstacles:", error);
                // Ensure we always have a working pathfinder even if there's an error
                this.leafNodes = [];
                this.nodeMap.clear();
                
                // Create a simple fallback tree
                const fallbackNode = new QuadTreeNode(0, 0, this.root.width, this.root.height);
                fallbackNode.walkable = true;
                this.leafNodes.push(fallbackNode);
                this.nodeMap.set(fallbackNode.id, fallbackNode);
            }
        }
    }
    
    // ========== ROOM CLASS ==========
    class Room {
        constructor(x, y, width, height, id) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.id = id;
            this.state = roomStates.LOCKED;
            this.doors = [];
            this.enemies = [];
            this.clearedTime = 0;
        }
        
        contains(x, y) {
            return x >= this.x && x < this.x + this.width &&
                   y >= this.y && y < this.y + this.height;
        }
        
        addDoor(door) {
            this.doors.push(door);
            door.room = this;
        }
        
        addEnemy(enemy) {
            this.enemies.push(enemy);
            enemy.room = this;
        }
        
        checkCleared() {
            if (this.state === roomStates.LOCKED) return false;
            
            // Check if all enemies in this room are defeated
            for (const enemy of enemies) {
                if (enemy.room === this.id) {
                    return false;
                }
            }
            
            // If we get here, the room is cleared
            if (this.state !== roomStates.CLEARED) {
                this.state = roomStates.CLEARED;
                this.clearedTime = Date.now();
                
                // Unlock all doors in this room
                for (const door of this.doors) {
                    door.isLocked = false;
                }
                
                // Show room cleared notification
                floatingTexts.push(new FloatingText(
                    this.x + this.width / 2, 
                    this.y + this.height / 2, 
                    'ROOM CLEARED', 
                    '#00ff00',
                    30,
                    0.5
                ));
                
                // Award points for clearing the room
                const timeTaken = (Date.now() - this.clearedTime) / 1000;
                const timeBonus = Math.max(0, 500 - Math.floor(timeTaken * 10));
                score += 500 + timeBonus;
                
                floatingTexts.push(new FloatingText(
                    this.x + this.width / 2, 
                    this.y + this.height / 2 + 40, 
                    `+${500 + timeBonus}`, 
                    '#ffff00',
                    20,
                    0.5
                ));
                
                updateHUD();
            }
            
            return true;
        }
        
        draw(ctx) {
            // Draw room outline
            if (this.state === roomStates.LOCKED) {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    this.x - camera.x, 
                    this.y - camera.y, 
                    this.width, 
                    this.height
                );
            } else if (this.state === roomStates.CLEARED) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.2)';
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    this.x - camera.x, 
                    this.y - camera.y, 
                    this.width, 
                    this.height
                );
            }
            
            // Draw room ID in debug mode
            if (keys['tab']) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `Room ${this.id}`, 
                    this.x + this.width / 2 - camera.x, 
                    this.y + 15 - camera.y
                );
            }
        }
    }
    
    // ========== AMMO DROP CLASS ==========
    class AmmoDrop {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.size = ammoTypes[type].size;
            this.color = ammoTypes[type].color;
            this.symbol = ammoTypes[type].symbol;
            this.value = ammoTypes[type].value;
            this.bobOffset = Math.random() * Math.PI * 2;
            this.pulsePhase = 0;
        }
        
        update() {
            this.pulsePhase += 0.05;
            
            // Check collision with player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < player.size + this.size) {
                this.collect();
                return true; // Ammo collected
            }
            
            return false;
        }
        
        collect() {
            // Add ammo to the appropriate weapon
            if (this.type === 'pistol') {
                player.pistolAmmo = Math.min(weaponProperties.pistol.maxAmmo, player.pistolAmmo + this.value);
            } else if (this.type === 'shotgun') {
                player.shotgunAmmo = Math.min(weaponProperties.shotgun.maxAmmo, player.shotgunAmmo + this.value);
            } else if (this.type === 'sniper') {
                player.sniperAmmo = Math.min(weaponProperties.sniper.maxAmmo, player.sniperAmmo + this.value);
            }
            
            // Create collection effect
            createParticles(this.x, this.y, this.color, 15, 3);
            
            // Show pickup text
            floatingTexts.push(new FloatingText(
                this.x, 
                this.y - this.size, 
                `+${this.value} ${this.type.toUpperCase()} AMMO`, 
                this.color
            ));
            
            soundManager.play('pickup');
            updateHUD();
        }
        
        draw(ctx) {
            const bobY = Math.sin(Date.now() / 200 + this.bobOffset) * 3;
            const pulseSize = this.size + Math.sin(this.pulsePhase) * 2;
            
            // Draw glow
            const gradient = ctx.createRadialGradient(
                this.x - camera.x, this.y + bobY - camera.y, 0,
                this.x - camera.x, this.y + bobY - camera.y, pulseSize * 1.5
            );
            gradient.addColorStop(0, `${this.color}80`);
            gradient.addColorStop(1, `${this.color}00`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(this.x - camera.x, this.y + bobY - camera.y, pulseSize * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw ammo
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x - camera.x, this.y + bobY - camera.y, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw symbol
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${pulseSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.symbol, this.x - camera.x, this.y + bobY - camera.y);
        }
    }
    
    // ========== ENHANCED EXPLOSION CLASS ==========
    class Explosion {
        constructor(x, y, radius, damage) {
            this.x = x;
            this.y = y;
            this.radius = 0;
            this.maxRadius = radius;
            this.damage = damage;
            this.particles = [];
            this.life = 30;
            this.shockwaves = []; // Multiple shockwaves for better effect
            
            // Create explosion particles with more variety
            for (let i = 0; i < 80; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 2;
                const size = Math.random() * 10 + 2;
                
                // Different particle types
                const particleType = Math.random();
                let color;
                
                if (particleType < 0.7) {
                    // Orange/red fire particles
                    color = `hsl(${Math.random() * 60}, 100%, 50%)`;
                } else {
                    // Yellow/white sparks
                    color = `hsl(${45 + Math.random() * 15}, 100%, ${70 + Math.random() * 30}%)`;
                }
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: size,
                    color: color,
                    life: 30 + Math.random() * 20,
                    gravity: 0.1 + Math.random() * 0.1
                });
            }
            
            // Create multiple shockwaves
            for (let i = 0; i < 3; i++) {
                this.shockwaves.push({
                    radius: 0,
                    maxRadius: radius * (0.7 + i * 0.3),
                    delay: i * 5,
                    life: 30 + i * 5
                });
            }
            
            // Screen shake effect
            shakeScreen(20);
            soundManager.play('explosion');
        }
        
        update() {
            this.life--;
            
            // Update shockwaves
            for (const wave of this.shockwaves) {
                if (wave.delay > 0) {
                    wave.delay--;
                } else {
                    wave.life--;
                    wave.radius += this.maxRadius / 30;
                }
            }
            
            // Update particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity; // Apply gravity
                p.vx *= 0.95; // Air resistance
                p.vy *= 0.95;
                p.life--;
                p.size *= 0.95;
                
                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                }
            }
            
            // Check collision with player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < this.radius && !player.invulnerable && !player.isDead) {
                const damage = this.damage * (1 - distance / this.maxRadius);
                player.health -= damage;
                player.invulnerable = true;
                player.invulnerableTime = 60;
                createBloodSplatter(player.x, player.y, 5);
                shakeScreen(15);
                camera.flashIntensity = 20;
                updateHUD();
                soundManager.play('playerHit');
                
                if (player.health <= 0) {
                    playerDeath();
                }
            }
            
            // Check collision with enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.radius) {
                    const damage = this.damage * (1 - distance / this.maxRadius);
                    enemy.health -= damage;
                    
                    // Apply knockback
                    const knockbackForce = 5;
                    const angle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(angle) * knockbackForce;
                    enemy.y += Math.sin(angle) * knockbackForce;
                    
                    if (enemy.health <= 0) {
                        if (enemy.type === 'suicide' && enemy.explodesOnDeath) {
                            createExplosion(enemy.x, enemy.y, enemy.explosionRadius);
                        }
                        
                        enemies.splice(i, 1);
                        kills++;
                        explosionKills++;
                        
                        let points = enemyTypes[enemy.type].points;
                        const comboMultiplier = Math.min(combo, 10);
                        points *= comboMultiplier;
                        
                        score += points;
                        
                        let comboText = combo > 1 ? ` x${combo} COMBO!` : '';
                        floatingTexts.push(new FloatingText(
                            enemy.x, 
                            enemy.y - enemy.size, 
                            `+${points}${comboText}`, 
                            combo > 1 ? '#ffff00' : '#00ff00'
                        ));
                        
                        const now = Date.now();
                        if (now - lastKillTime < 2000) {
                            combo++;
                        } else {
                            combo = 1;
                        }
                        lastKillTime = now;
                        
                        createBloodSplatter(enemy.x, enemy.y, 10);
                        shakeScreen(5);
                        soundManager.play('enemyDeath');
                        
                        updateHUD();
                        checkAchievements();
                    }
                }
            }
            
            // Check collision with doors
            for (const door of doors) {
                if (!door.isBroken) {
                    const dx = (door.x + door.width/2) - this.x;
                    const dy = (door.y + door.height/2) - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < this.radius) {
                        door.health -= 2;
                        createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                        
                        if (door.health <= 0) {
                            door.isBroken = true;
                            createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                            shakeScreen(5);
                            soundManager.play('doorBreak');
                        }
                    }
                }
            }
            
            // Expand explosion radius
            if (this.radius < this.maxRadius) {
                this.radius += this.maxRadius / 15;
            }
            
            return this.life <= 0;
        }
        
        draw(ctx) {
            // Draw shockwaves
            for (const wave of this.shockwaves) {
                if (wave.delay <= 0 && wave.life > 0) {
                    const alpha = wave.life / 30;
                    ctx.strokeStyle = `rgba(255, 100, 0, ${alpha * 0.7})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x - camera.x, this.y - camera.y, wave.radius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Draw explosion glow
            const gradient = ctx.createRadialGradient(
                this.x - camera.x, this.y - camera.y, 0,
                this.x - camera.x, this.y - camera.y, this.radius
            );
            gradient.addColorStop(0, `rgba(255, 255, 200, ${this.life / 60})`);
            gradient.addColorStop(0.4, `rgba(255, 150, 0, ${this.life / 90})`);
            gradient.addColorStop(0.8, `rgba(255, 50, 0, ${this.life / 120})`);
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(this.x - camera.x, this.y - camera.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw particles
            for (const p of this.particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 50;
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }
    }
    
    // ========== BULLET TRAIL CLASS ==========
    class BulletTrail {
        constructor(x, y, angle, length, color, life) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.length = length;
            this.color = color;
            this.life = life;
            this.maxLife = life;
        }
        
        update() {
            this.life--;
            return this.life <= 0;
        }
        
        draw(ctx) {
            const alpha = this.life / this.maxLife;
            ctx.strokeStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x - camera.x, this.y - camera.y);
            ctx.lineTo(
                this.x - Math.cos(this.angle) * this.length - camera.x,
                this.y - Math.sin(this.angle) * this.length - camera.y
            );
            ctx.stroke();
        }
    }
    
    // ========== WALL DECAL CLASS ==========
    class WallDecal {
        constructor(x, y, angle, size, color) {
            this.x = x;
            this.y = y;
            this.angle = angle;
            this.size = size;
            this.color = color;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x - camera.x, this.y - camera.y);
            ctx.rotate(this.angle);
            
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
    }
    
    // ========== POWER-UP CLASS ==========
    class PowerUp {
        constructor(x, y, type) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.size = powerUpTypes[type].size;
            this.color = powerUpTypes[type].color;
            this.symbol = powerUpTypes[type].symbol;
            this.bobOffset = Math.random() * Math.PI * 2;
            this.pulsePhase = 0;
            this.rotationSpeed = 0.02;
            this.rotation = 0;
        }
        
        update() {
            this.pulsePhase += 0.05;
            this.rotation += this.rotationSpeed;
            
            // Check collision with player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < player.size + this.size) {
                this.applyEffect();
                return true; // Power-up collected
            }
            
            return false;
        }
        
        applyEffect() {
            const powerUp = powerUpTypes[this.type];
            
            switch (powerUp.effect) {
                case 'health':
                    player.health = Math.min(player.maxHealth, player.health + powerUp.value);
                    createParticles(this.x, this.y, '#ff0000', 20, 3);
                    floatingTexts.push(new FloatingText(
                        this.x, 
                        this.y - this.size, 
                        `+${powerUp.value} HEALTH`, 
                        '#ff0000'
                    ));
                    break;
                    
                case 'speed':
                    player.speedMultiplier = powerUp.value;
                    player.powerUpTimers.speed = powerUp.duration;
                    createParticles(this.x, this.y, '#00ff00', 20, 3);
                    floatingTexts.push(new FloatingText(
                        this.x, 
                        this.y - this.size, 
                        'SPEED BOOST!', 
                        '#00ff00'
                    ));
                    break;
                    
                case 'rapidFire':
                    player.fireRateMultiplier = powerUp.value;
                    player.powerUpTimers.rapidFire = powerUp.duration;
                    createParticles(this.x, this.y, '#ffff00', 20, 3);
                    floatingTexts.push(new FloatingText(
                        this.x, 
                        this.y - this.size, 
                        'RAPID FIRE!', 
                        '#ffff00'
                    ));
                    break;
                    
                case 'damage':
                    player.damageMultiplier = powerUp.value;
                    player.powerUpTimers.damage = powerUp.duration;
                    createParticles(this.x, this.y, '#ff00ff', 20, 3);
                    floatingTexts.push(new FloatingText(
                        this.x, 
                        this.y - this.size, 
                        'DAMAGE BOOST!', 
                        '#ff00ff'
                    ));
                    break;
                    
                case 'invulnerability':
                    player.invulnerable = true;
                    player.powerUpTimers.invulnerability = powerUp.duration;
                    createParticles(this.x, this.y, '#00ffff', 20, 3);
                    floatingTexts.push(new FloatingText(
                        this.x, 
                        this.y - this.size, 
                        'INVULNERABILITY!', 
                        '#00ffff'
                    ));
                    break;
                    
                case 'ammo':
                    // Refill all ammo
                    player.pistolAmmo = weaponProperties.pistol.maxAmmo;
                    player.shotgunAmmo = weaponProperties.shotgun.maxAmmo;
                    player.sniperAmmo = weaponProperties.sniper.maxAmmo;
                    createParticles(this.x, this.y, '#ffffff', 20, 3);
                    floatingTexts.push(new FloatingText(
                        this.x, 
                        this.y - this.size, 
                        'AMMO REFILL!', 
                        '#ffffff'
                    ));
                    break;
            }
            
            soundManager.play('pickup');
            score += 200;
            updateHUD();
        }
        
        draw(ctx) {
            const bobY = Math.sin(Date.now() / 200 + this.bobOffset) * 5;
            const pulseSize = this.size + Math.sin(this.pulsePhase) * 3;
            
            ctx.save();
            ctx.translate(this.x - camera.x, this.y + bobY - camera.y);
            ctx.rotate(this.rotation);
            
            // Draw glow
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize * 2);
            gradient.addColorStop(0, `${this.color}80`);
            gradient.addColorStop(1, `${this.color}00`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, pulseSize * 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw power-up
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw symbol
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${pulseSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(this.symbol, 0, 0);
            
            ctx.restore();
        }
    }
    
    // ========== MINI-MAP CLASS ==========
    class MiniMap {
        constructor() {
            this.width = 200;
            this.height = 120;
            this.x = canvas.width - this.width - 20;
            this.y = 20;
            this.scale = 0.05;
            this.showEnemies = true;
            this.showPowerUps = true;
            this.showRooms = true;
        }
        
        draw(ctx) {
            // Draw background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(this.x, this.y, this.width, this.height);
            
            // Draw border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(this.x, this.y, this.width, this.height);
            
            // Calculate map offset to center on player
            const mapCenterX = this.x + this.width / 2;
            const mapCenterY = this.y + this.height / 2;
            
            // Draw rooms
            if (this.showRooms) {
                for (const room of rooms) {
                    let roomColor = 'rgba(100, 100, 100, 0.5)';
                    if (room.state === roomStates.LOCKED) {
                        roomColor = 'rgba(255, 0, 0, 0.3)';
                    } else if (room.state === roomStates.CLEARED) {
                        roomColor = 'rgba(0, 255, 0, 0.2)';
                    }
                    
                    ctx.fillStyle = roomColor;
                    ctx.fillRect(
                        mapCenterX + (room.x - player.x) * this.scale,
                        mapCenterY + (room.y - player.y) * this.scale,
                        room.width * this.scale,
                        room.height * this.scale
                    );
                }
            }
            
            // Draw walls
            ctx.fillStyle = '#553300';
            for (const wall of walls) {
                const wallX = mapCenterX + (wall.x - player.x) * this.scale;
                const wallY = mapCenterY + (wall.y - player.y) * this.scale;
                const wallWidth = wall.width * this.scale;
                const wallHeight = wall.height * this.scale;
                
                if (wallX + wallWidth > this.x && 
                    wallX < this.x + this.width &&
                    wallY + wallHeight > this.y && 
                    wallY < this.y + this.height) {
                    ctx.fillRect(wallX, wallY, wallWidth, wallHeight);
                }
            }
            
            // Draw doors
            ctx.fillStyle = '#8B4513';
            for (const door of doors) {
                if (!door.isBroken) {
                    const doorX = mapCenterX + (door.x - player.x) * this.scale;
                    const doorY = mapCenterY + (door.y - player.y) * this.scale;
                    const doorWidth = door.width * this.scale;
                    const doorHeight = door.height * this.scale;
                    
                    if (doorX + doorWidth > this.x && 
                        doorX < this.x + this.width &&
                        doorY + doorHeight > this.y && 
                        doorY < this.y + this.height) {
                        ctx.fillRect(doorX, doorY, doorWidth, doorHeight);
                    }
                }
            }
            
            // Draw exit portal
            if (exitPortal) {
                ctx.fillStyle = '#00ffff';
                const portalX = mapCenterX + (exitPortal.x - player.x) * this.scale;
                const portalY = mapCenterY + (exitPortal.y - player.y) * this.scale;
                
                if (portalX > this.x && 
                    portalX < this.x + this.width &&
                    portalY > this.y && 
                    portalY < this.y + this.height) {
                    ctx.beginPath();
                    ctx.arc(portalX, portalY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw boss
            if (boss) {
                ctx.fillStyle = '#ff00ff';
                const bossX = mapCenterX + (boss.x - player.x) * this.scale;
                const bossY = mapCenterY + (boss.y - player.y) * this.scale;
                
                if (bossX > this.x && 
                    bossX < this.x + this.width &&
                    bossY > this.y && 
                    bossY < this.y + this.height) {
                    ctx.beginPath();
                    ctx.arc(bossX, bossY, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw enemies
            if (this.showEnemies) {
                for (const enemy of enemies) {
                    ctx.fillStyle = enemy.color;
                    const enemyX = mapCenterX + (enemy.x - player.x) * this.scale;
                    const enemyY = mapCenterY + (enemy.y - player.y) * this.scale;
                    
                    if (enemyX > this.x && 
                        enemyX < this.x + this.width &&
                        enemyY > this.y && 
                        enemyY < this.y + this.height) {
                        ctx.beginPath();
                        ctx.arc(enemyX, enemyY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Draw power-ups
            if (this.showPowerUps) {
                for (const powerUp of powerUps) {
                    ctx.fillStyle = powerUp.color;
                    const powerUpX = mapCenterX + (powerUp.x - player.x) * this.scale;
                    const powerUpY = mapCenterY + (powerUp.y - player.y) * this.scale;
                    
                    if (powerUpX > this.x && 
                        powerUpX < this.x + this.width &&
                        powerUpY > this.y && 
                        powerUpY < this.y + this.height) {
                        ctx.beginPath();
                        ctx.arc(powerUpX, powerUpY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Draw player
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(mapCenterX, mapCenterY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw player direction indicator
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(mapCenterX, mapCenterY);
            ctx.lineTo(
                mapCenterX + Math.cos(player.angle) * 10,
                mapCenterY + Math.sin(player.angle) * 10
            );
            ctx.stroke();
            
            // Draw title
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('MINIMAP', this.x + this.width / 2, this.y - 5);
        }
    }
    
    const miniMap = new MiniMap();
    
    // ========== SOUND MANAGER ==========
    class SoundManager {
        constructor() {
            this.sounds = {};
            this.enabled = true;
            this.volume = 0.5;
        }
        
        load(name, src) {
            const audio = new Audio(src);
            this.sounds[name] = audio;
        }
        
        play(name, volume = 1.0) {
            if (!this.enabled || !this.sounds[name]) return;
            
            const sound = this.sounds[name].cloneNode();
            sound.volume = volume * this.volume;
            sound.play().catch(e => console.log('Sound play error:', e));
        }
        
        toggle() {
            this.enabled = !this.enabled;
            return this.enabled;
        }
    }
    
    const soundManager = new SoundManager();
    
    // ========== FLOATING TEXT CLASS ==========
    class FloatingText {
        constructor(x, y, text, color = '#ffffff', size = 20, speed = 1, scaleSpeed = 0.02) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.size = size;
            this.speed = speed;
            this.life = 60;
            this.alpha = 1;
            this.scale = 1;
            this.growing = true;
            this.scaleSpeed = scaleSpeed;
        }
        
        update() {
            this.y -= this.speed;
            this.life--;
            this.alpha = this.life / 60;
            
            if (this.growing) {
                this.scale += this.scaleSpeed;
                if (this.scale >= 1.2) {
                    this.growing = false;
                }
            } else {
                this.scale -= this.scaleSpeed / 2;
            }
        }
        
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.translate(this.x, this.y);
            ctx.scale(this.scale, this.scale);
            ctx.fillStyle = this.color;
            ctx.font = `bold ${this.size}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillText(this.text, 0, 0);
            ctx.restore();
        }
    }
    
    // ========== EXIT PORTAL CLASS ==========
    class ExitPortal {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 30;
            this.rotation = 0;
            this.pulsePhase = 0;
            this.active = false;
            this.particles = [];
            this.wavePhase = 0;
        }
        
        update() {
            this.rotation += 0.02;
            this.pulsePhase += 0.05;
            this.wavePhase += 0.03;
            
            if (Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * this.size;
                this.particles.push({
                    x: this.x + Math.cos(angle) * distance,
                    y: this.y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    size: Math.random() * 5 + 2,
                    life: 30
                });
            }
            
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    this.particles.splice(i, 1);
                }
            }
            
            // Activate portal when all enemies are defeated
            if (enemies.length === 0 && !boss) {
                this.active = true;
            }
        }
        
        draw(ctx) {
            // Draw particles
            for (const p of this.particles) {
                ctx.fillStyle = `rgba(0, 255, 255, ${p.life / 30})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            
            const pulseSize = this.size + Math.sin(this.pulsePhase) * 5;
            
            // Draw portal waves
            for (let i = 0; i < 5; i++) {
                const waveSize = pulseSize * (1 + i * 0.3);
                const alpha = 0.5 - i * 0.1;
                const waveOffset = this.wavePhase * (i + 1);
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                    const radius = waveSize + Math.sin(angle * 5 + waveOffset) * 5;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    if (angle === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw portal core
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pulseSize);
            gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
            gradient.addColorStop(0.7, 'rgba(0, 150, 255, 0.5)');
            gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw portal symbol
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${pulseSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('E', 0, 0);
            
            ctx.restore();
            
            // Draw activation indicator
            if (this.active) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseSize * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, pulseSize * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        
        checkCollision(player) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < player.size + this.size;
        }
    }
    
    // ========== BOSS CLASS ==========
    class Boss {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.size = 50;
            this.angle = 0;
            this.health = 500;
            this.maxHealth = 500;
            this.speed = 0.3;
            this.attackCooldown = 0;
            this.phase = 1;
            this.projectiles = [];
            this.summonCooldown = 0;
            this.vulnerable = true;
            this.attackPattern = 0;
            this.patternTimer = 0;
            this.moveAngle = 0;
            this.moveRadius = 100;
            this.moveSpeed = 0.02;
        }
        
        update() {
            // Movement pattern
            this.moveAngle += this.moveSpeed;
            const targetX = this.x + Math.cos(this.moveAngle) * this.moveRadius;
            const targetY = this.y + Math.sin(this.moveAngle) * this.moveRadius;
            
            this.x = targetX;
            this.y = targetY;
            
            // Face player
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            this.angle = Math.atan2(dy, dx);
            
            // Update timers
            if (this.attackCooldown > 0) this.attackCooldown--;
            if (this.summonCooldown > 0) this.summonCooldown--;
            this.patternTimer++;
            
            // Phase transitions
            if (this.health < this.maxHealth * 0.66 && this.phase === 1) {
                this.phase = 2;
                this.moveSpeed = 0.03;
                createParticles(this.x, this.y, '#ff0000', 50, 5);
                shakeScreen(20);
                floatingTexts.push(new FloatingText(
                    this.x, 
                    this.y - this.size, 
                    'PHASE 2!', 
                    '#ff0000',
                    30
                ));
            }
            
            if (this.health < this.maxHealth * 0.33 && this.phase === 2) {
                this.phase = 3;
                this.moveSpeed = 0.04;
                createParticles(this.x, this.y, '#ff00ff', 50, 5);
                shakeScreen(30);
                floatingTexts.push(new FloatingText(
                    this.x, 
                    this.y - this.size, 
                    'PHASE 3!', 
                    '#ff00ff',
                    30
                ));
            }
            
            // Attack patterns
            if (this.attackCooldown <= 0) {
                switch (this.phase) {
                    case 1:
                        // Phase 1: Simple projectile attack
                        this.shootProjectile();
                        this.attackCooldown = 80;
                        break;
                        
                    case 2:
                        // Phase 2: Shotgun spread and summoning
                        if (this.attackPattern === 0) {
                            this.shootShotgunSpread();
                            this.attackCooldown = 80;
                            this.attackPattern = 1;
                        } else {
                            this.summonMinions();
                            this.attackCooldown = 120;
                            this.attackPattern = 0;
                        }
                        break;
                        
                    case 3:
                        // Phase 3: Complex patterns
                        if (this.patternTimer % 180 === 0) {
                            this.circularAttack();
                            this.attackCooldown = 60;
                        } else if (this.patternTimer % 120 === 0) {
                            this.shootShotgunSpread();
                            this.attackCooldown = 60;
                        } else if (this.patternTimer % 300 === 0) {
                            this.summonMinions();
                            this.attackCooldown = 120;
                        }
                        break;
                }
            }
            
            // Update projectiles
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const proj = this.projectiles[i];
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.life--;
                
                const dx = proj.x - player.x;
                const dy = proj.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < proj.size + player.size) {
                    if (!player.invulnerable && !player.isDead) {
                        player.health -= proj.damage;
                        player.invulnerable = true;
                        player.invulnerableTime = 60;
                        createBloodSplatter(player.x, player.y, 5);
                        shakeScreen(10);
                        camera.flashIntensity = 15;
                        updateHUD();
                        soundManager.play('playerHit');
                        
                        if (player.health <= 0) {
                            playerDeath();
                        }
                    }
                    
                    this.projectiles.splice(i, 1);
                    continue;
                }
                
                if (proj.life <= 0 || 
                    proj.x < 0 || proj.x > worldWidth || 
                    proj.y < 0 || proj.y > worldHeight) {
                    this.projectiles.splice(i, 1);
                }
            }
        }
        
        shootProjectile() {
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            
            this.projectiles.push({
                x: this.x,
                y: this.y,
                vx: Math.cos(angle) * 5,
                vy: Math.sin(angle) * 5,
                size: 10,
                damage: 20,
                life: 120,
                color: '#ff00ff'
            });
            
            createParticles(this.x, this.y, '#ff00ff', 10, 3);
        }
        
        shootShotgunSpread() {
            const baseAngle = Math.atan2(player.y - this.y, player.x - this.x);
            const pelletCount = 8 + this.phase * 2; // More pellets in higher phases
            const spreadAngle = Math.PI / 8;
            
            for (let i = 0; i < pelletCount; i++) {
                const angle = baseAngle + (i - pelletCount/2) * spreadAngle / pelletCount;
                
                this.projectiles.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * 4,
                    vy: Math.sin(angle) * 4,
                    size: 8,
                    damage: 15,
                    life: 120,
                    color: '#ff00ff'
                });
            }
            
            createParticles(this.x, this.y, '#ff00ff', 20, 4);
        }
        
        circularAttack() {
            const projectileCount = 12 + this.phase * 4;
            
            for (let i = 0; i < projectileCount; i++) {
                const angle = (i / projectileCount) * Math.PI * 2;
                
                this.projectiles.push({
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * 3,
                    vy: Math.sin(angle) * 3,
                    size: 8,
                    damage: 10,
                    life: 180,
                    color: '#ff00ff'
                });
            }
            
            createParticles(this.x, this.y, '#ff00ff', 30, 5);
            shakeScreen(10);
        }
        
        summonMinions() {
            const minionCount = 2 + this.phase;
            
            for (let i = 0; i < minionCount; i++) {
                const angle = (i / minionCount) * Math.PI * 2;
                const distance = 100;
                const spawnX = this.x + Math.cos(angle) * distance;
                const spawnY = this.y + Math.sin(angle) * distance;
                
                // Determine minion type based on phase
                let minionType = 'basic';
                if (this.phase === 2) {
                    minionType = Math.random() < 0.5 ? 'basic' : 'sniper';
                } else if (this.phase === 3) {
                    const rand = Math.random();
                    if (rand < 0.4) minionType = 'basic';
                    else if (rand < 0.7) minionType = 'sniper';
                    else minionType = 'heavy';
                }
                
                enemies.push({
                    x: spawnX,
                    y: spawnY,
                    type: minionType,
                    angle: 0,
                    attackCooldown: 0
                });
                
                const newEnemy = enemies[enemies.length - 1];
                const type = enemyTypes[minionType];
                Object.assign(newEnemy, {
                    health: type.health,
                    maxHealth: type.maxHealth,
                    speed: type.speed,
                    size: type.size,
                    color: type.color,
                    hasKnife: type.hasKnife,
                    attackDamage: type.attackDamage,
                    attackRange: type.attackRange,
                    detectionRange: type.detectionRange,
                    fireRate: type.fireRate || 60,
                    canShootThroughWalls: type.canShootThroughWalls || false,
                    bulletSpeed: type.bulletSpeed || 10,
                    path: [],
                    pathIndex: 0,
                    pathUpdateCounter: 0,
                    shouldFlash: false,
                    forcePathUpdate: false
                });
            }
            
            createParticles(this.x, this.y, '#9933ff', 30, 5);
            floatingTexts.push(new FloatingText(
                this.x, 
                this.y - this.size, 
                'MINIONS SUMMONED!', 
                '#9933ff',
                24
            ));
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x - camera.x, this.y - camera.y);
            ctx.rotate(this.angle);
            
            // Boss body with phase-based colors
            let bodyColor = '#9900ff';
            if (this.phase === 2) bodyColor = '#ff0099';
            if (this.phase === 3) bodyColor = '#ff0000';
            
            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss eyes
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(-this.size/3, -this.size/3, this.size/5, 0, Math.PI * 2);
            ctx.arc(this.size/3, -this.size/3, this.size/5, 0, Math.PI * 2);
            ctx.fill();
            
            // Boss mouth
            ctx.beginPath();
            ctx.arc(0, this.size/4, this.size/3, 0, Math.PI);
            ctx.stroke();
            
            // Vulnerability indicator
            if (this.vulnerable) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.size + 5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Phase indicators
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`P${this.phase}`, 0, 0);
            
            ctx.restore();
            
            // Draw projectiles
            for (const proj of this.projectiles) {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x - camera.x, proj.y - camera.y, proj.size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Boss health bar
            const barWidth = 600;
            const barHeight = 20;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = 30;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
            
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(barX, barY, barWidth * (this.health / this.maxHealth), barHeight);
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('MEGA BOSS', canvas.width / 2, barY - 10);
            ctx.fillText(`PHASE ${this.phase}`, canvas.width / 2, barY + barHeight + 20);
        }
        
        takeDamage(damage) {
            if (!this.vulnerable) return false;
            
            this.health -= damage;
            createParticles(this.x, this.y, '#ff0000', 10, 3);
            shakeScreen(5);
            
            if (this.health <= 0) {
                createExplosion(this.x, this.y, 150);
                score += 5000;
                floatingTexts.push(new FloatingText(
                    this.x, 
                    this.y - this.size, 
                    '+5000 BOSS DEFEATED!', 
                    '#ffff00',
                    30
                ));
                soundManager.play('enemyDeath');
                unlockAchievement('bossSlayer');
                return true;
            }
            
            return false;
        }
    }
    
    // ========== ACHIEVEMENT SYSTEM ==========
    const achievements = [
        {
            id: 'firstKill',
            name: 'First Blood',
            description: 'Kill your first enemy',
            unlocked: false,
            check: () => kills >= 1
        },
        {
            id: 'comboMaster',
            name: 'Combo Master',
            description: 'Reach a 5x combo',
            unlocked: false,
            check: () => combo >= 5
        },
        {
            id: 'bossSlayer',
            name: 'Boss Slayer',
            description: 'Defeat the mega boss',
            unlocked: false,
            check: () => false
        },
        {
            id: 'perfectLevel',
            name: 'Perfect Level',
            description: 'Complete the level without taking damage',
            unlocked: false,
            check: () => levelComplete && player.health === player.maxHealth
        },
        {
            id: 'speedDemon',
            name: 'Speed Demon',
            description: 'Complete the level in under 2 minutes',
            unlocked: false,
            check: () => levelComplete && (Date.now() - levelStartTime) < 120000
        },
        {
            id: 'powerUpCollector',
            name: 'Power-Up Collector',
            description: 'Collect 10 power-ups',
            unlocked: false,
            check: () => false // Will be tracked separately
        },
        {
            id: 'exploder',
            name: 'Exploder',
            description: 'Kill 5 enemies with explosions',
            unlocked: false,
            check: () => false // Will be tracked separately
        },
        {
            id: 'survivor',
            name: 'Survivor',
            description: 'Survive 10 status effects',
            unlocked: false,
            check: () => false // Will be tracked separately
        },
        {
            id: 'wallBanger',
            name: 'Wall Banger',
            description: 'Destroy 10 doors',
            unlocked: false,
            check: () => false // Will be tracked separately
        },
        {
            id: 'sharpshooter',
            name: 'Sharpshooter',
            description: 'Kill 10 enemies with the sniper rifle',
            unlocked: false,
            check: () => false // Will be tracked separately
        },
        {
            id: 'executioner',
            name: 'Executioner',
            description: 'Execute 10 enemies',
            unlocked: false,
            check: () => false // Will be tracked separately
        },
        {
            id: 'headhunter',
            name: 'Headhunter',
            description: 'Get 10 headshots',
            unlocked: false,
            check: () => false // Will be tracked separately
        },
        {
            id: 'roomClearer',
            name: 'Room Clearer',
            description: 'Clear 10 rooms',
            unlocked: false,
            check: () => false // Will be tracked separately
        }
    ];
    
    let showAchievement = null;
    let achievementTimer = 0;
    let powerUpsCollected = 0;
    let explosionKills = 0;
    let statusEffectsSurvived = 0;
    let doorsDestroyed = 0;
    let sniperKills = 0;
    let roomsCleared = 0;
    
    function unlockAchievement(id) {
        const achievement = achievements.find(a => a.id === id);
        if (achievement && !achievement.unlocked) {
            achievement.unlocked = true;
            showAchievement = achievement;
            achievementTimer = 180;
            
            soundManager.play('pickup');
            
            score += 1000;
            floatingTexts.push(new FloatingText(
                player.x, 
                player.y - player.size - 30, 
                'ACHIEVEMENT UNLOCKED!', 
                '#ffff00',
                24
            ));
        }
    }
    
    function checkAchievements() {
        for (const achievement of achievements) {
            if (!achievement.unlocked && achievement.check()) {
                unlockAchievement(achievement.id);
            }
        }
        
        // Check power-up collector achievement
        if (powerUpsCollected >= 10 && !achievements.find(a => a.id === 'powerUpCollector').unlocked) {
            unlockAchievement('powerUpCollector');
        }
        
        // Check exploder achievement
        if (explosionKills >= 5 && !achievements.find(a => a.id === 'exploder').unlocked) {
            unlockAchievement('exploder');
        }
        
        // Check survivor achievement
        if (statusEffectsSurvived >= 10 && !achievements.find(a => a.id === 'survivor').unlocked) {
            unlockAchievement('survivor');
        }
        
        // Check wall banger achievement
        if (doorsDestroyed >= 10 && !achievements.find(a => a.id === 'wallBanger').unlocked) {
            unlockAchievement('wallBanger');
        }
        
        // Check sharpshooter achievement
        if (sniperKills >= 10 && !achievements.find(a => a.id === 'sharpshooter').unlocked) {
            unlockAchievement('sharpshooter');
        }
        
        // Check executioner achievement
        if (executionKills >= 10 && !achievements.find(a => a.id === 'executioner').unlocked) {
            unlockAchievement('executioner');
        }
        
        // Check headhunter achievement
        if (headshotKills >= 10 && !achievements.find(a => a.id === 'headhunter').unlocked) {
            unlockAchievement('headhunter');
        }
        
        // Check room clearer achievement
        if (roomsCleared >= 10 && !achievements.find(a => a.id === 'roomClearer').unlocked) {
            unlockAchievement('roomClearer');
        }
    }
    
    // ========== INPUT HANDLING ==========
    const keys = {};
    const mouse = { x: 0, y: 0, isDown: false, wasDown: false };
    
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
    });
    
    canvas.addEventListener('mousedown', () => {
        mouse.isDown = true;
        
        // Check for execution
        if (player.canExecute && player.executionTarget && !player.isExecuting) {
            executeEnemy(player.executionTarget);
            return;
        }
        
        // Normal shooting
        if (player.shootCooldown === 0 && !player.isReloading && !player.isDead) {
            if (player.currentWeapon === 'pistol' && player.pistolAmmo > 0 && player.pistolSemiAuto) {
                shootPistol();
                player.pistolAmmo--;
                player.shootCooldown = Math.floor(weaponProperties.pistol.fireRate * player.fireRateMultiplier);
                player.pistolSemiAuto = false;
            } else if (player.currentWeapon === 'shotgun' && player.shotgunAmmo > 0 && player.isShotgunCocked) {
                shootShotgun();
                player.shotgunAmmo--;
                player.shootCooldown = Math.floor(weaponProperties.shotgun.fireRate * player.fireRateMultiplier);
                player.isShotgunCocked = false;
            } else if (player.currentWeapon === 'sniper' && player.sniperAmmo > 0 && player.isSniperReady) {
                shootSniper();
                player.sniperAmmo--;
                player.shootCooldown = Math.floor(weaponProperties.sniper.fireRate * player.fireRateMultiplier);
                player.isSniperReady = false;
            } else if (player.currentWeapon === 'melee') {
                meleeAttack();
                player.shootCooldown = Math.floor(weaponProperties.melee.fireRate * player.fireRateMultiplier);
            }
        }
    });
    
    canvas.addEventListener('mouseup', () => {
        mouse.isDown = false;
        player.pistolSemiAuto = true;
    });
    
    // ========== LEVEL INITIALIZATION ==========
    let pathfinder = null;
    
    function initLevel() {
        walls = [];
        doors = [];
        enemies = [];
        rooms = [];
        currentRoom = null;
        bloodSplatters = [];
        exitPortal = null;
        boss = null;
        powerUps = [];
        ammoDrops = [];
        explosions = [];
        wallDecals = [];
        bulletTrails = [];
        
        // Set default player position in case spawn point isn't found
        player.x = worldWidth / 2;
        player.y = worldHeight / 2;
        
        const levelLayout = [
"####################################################################################################",
"#...............#.......................#.......................#.......................#........#",
"#..P............+........S..............+...........H...........+..............H........+.......#",
"#...............#.......................#.......................#.......................#.......#",
"#######+##########+##########+##########+##########+##########+##########+##########+##########+#####",
"#       +#          +#          +#          +#          +#          +#          +#          +#    #",
"#   C     #   .-.     #   V      #   S      #   .-.     #   U      #   .-.     #   S      # L   #",
"#         +#          +#          +#          +#          +#          +#          +#          +#  #",
"#######+##########+##########+##########+##########+##########+##########+##########+##########+#####",
"#...............#.......................#.......................#.......................#.......#",
"#.......C.......+.............S.......+..............H........+...........V...........+.......H#",
"#...............#.......................#.......................#.......................#.......#",
"##########+##########+##########+##########+##########+##########+##########+##########+##########+#",
"#          +#          +#          +#          +#          +#          +#          +#          +#",
"#   S      #   V      #   C      #   .-.     #   S      #   H      #   U      #   .-.     #  V   #",
"#          +#          +#          +#          +#          +#          +#          +#          +#",
"##########+##########+##########+##########+##########+##########+##########+##########+##########+#",
"#...............#.......................#.......................#.......................#.......#",
"#.......S.......+...............V.......+...............S.......+...............H.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"#################x########################x########################x########################x######",
"#...............#.......................#.......................#.......................#.......#",
"#.......C.......+...........S...........+...............U.......+...............H.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"####################################################################################################",
"#...............#.......................#.......................#.......................#.......#",
"#...............#.......................#.......................#.......................#.......#",
"#.......S.......+...............H.......+...............C.......+...............V.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"#######+##########+##########+##########+##########+##########+##########+##########+##########+#####",
"#       +#          +#          +#          +#          +#          +#          +#          +#    #",
"#   C     #   .-.     #   H      #   U      #   .-.     #   V      #   S      #   .-.     # S   #",
"#         +#          +#          +#          +#          +#          +#          +#          +#  #",
"#######+##########+##########+##########+##########+##########+##########+##########+##########+#####",
"#...............#.......................#.......................#.......................#.......#",
"#.......V.......+...............S.......+...............H.......+...............C.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"#################x########################x########################x########################x######",
"#...............#.......................#.......................#.......................#.......#",
"#.......U.......+...........V...........+...............S.......+...............H.......+.......#",
"#...............#.......................#.......................#.......................#.......#",
"####################################################################################################",
"#...............#.......................#.......................#.......................#.......#",
"#..S............+.............H.......+..............C........+...........V...........+.......>#",
"#...............#.......................#.......................#.......................#.......#",
"####################################################################################################",
];
        
        const tileSize = 60;
        const levelWidth = levelLayout[0].length * tileSize;
        const levelHeight = levelLayout.length * tileSize;
        const offsetX = (worldWidth - levelWidth) / 2;
        const offsetY = (worldHeight - levelHeight) / 2;
        
        console.log(`Level dimensions: ${levelWidth}x${levelHeight}`);
        console.log(`World dimensions: ${worldWidth}x${worldHeight}`);
        console.log(`Level offset: ${offsetX}x${offsetY}`);
        
        let playerSpawned = false;
        
        // Create rooms based on the level layout
        let roomId = 1;
        for (let row = 1; row < levelLayout.length - 1; row += 6) {
            for (let col = 1; col < levelLayout[row].length - 1; col += 12) {
                // Check if this is a valid room position (not a wall)
                if (levelLayout[row][col] !== '#') {
                    const roomX = offsetX + col * tileSize;
                    const roomY = offsetY + row * tileSize;
                    const roomWidth = 12 * tileSize;
                    const roomHeight = 6 * tileSize;
                    
                    // Create the room
                    const room = new Room(roomX, roomY, roomWidth, roomHeight, roomId++);
                    rooms.push(room);
                }
            }
        }
        
        // Set the first room as unlocked
        if (rooms.length > 0) {
            rooms[0].state = roomStates.UNLOCKED;
            currentRoom = rooms[0];
        }
        
        for (let row = 0; row < levelLayout.length; row++) {
            for (let col = 0; col < levelLayout[row].length; col++) {
                const char = levelLayout[row][col];
                const x = offsetX + col * tileSize;
                const y = offsetY + row * tileSize;
                
                // Find which room this position belongs to
                let room = null;
                for (const r of rooms) {
                    if (r.contains(x, y)) {
                        room = r;
                        break;
                    }
                }
                
                switch (char) {
                    case '#':
                        walls.push({ 
                            x: x, 
                            y: y, 
                            width: tileSize, 
                            height: tileSize, 
                            type: 'interior',
                            room: room ? room.id : null
                        });
                        break;
                        
                    case '+':
                        const door = {
                            x: x, 
                            y: y, 
                            width: tileSize, 
                            height: tileSize, 
                            health: 2, 
                            maxHealth: 2, 
                            isBroken: false,
                            wasBroken: false,
                            isLocked: true,
                            room: room ? room.id : null
                        };
                        doors.push(door);
                        if (room) {
                            room.addDoor(door);
                        }
                        break;
                        
                    case 'x':
                        const strongDoor = {
                            x: x, 
                            y: y, 
                            width: tileSize, 
                            height: tileSize, 
                            health: 5, 
                            maxHealth: 5, 
                            isBroken: false,
                            wasBroken: false,
                            isLocked: true,
                            room: room ? room.id : null
                        };
                        doors.push(strongDoor);
                        if (room) {
                            room.addDoor(strongDoor);
                        }
                        break;
                        
                    case 'P':
                        player.x = x + tileSize / 2;
                        player.y = y + tileSize / 2;
                        playerSpawned = true;
                        console.log(`Player spawned at: ${player.x}, ${player.y}`);
                        
                        // Set player's current room
                        if (room) {
                            currentRoom = room;
                        }
                        break;
                        
                    case 'E':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'basic', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'H':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'shield', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'S':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'spawner', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'U':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'suicide', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'N':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'sniper', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'V':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'heavy', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'C':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'cloaker', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'L':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'hacker', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'F':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'fire', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case 'I':
                        enemies.push({ 
                            x: x + tileSize / 2, 
                            y: y + tileSize / 2, 
                            type: 'electric', 
                            angle: 0, 
                            attackCooldown: 0,
                            room: room ? room.id : null
                        });
                        break;
                        
                    case '>':
                        exitPortal = new ExitPortal(x + tileSize / 2, y + tileSize / 2);
                        break;
                        
                    case 'B':
                        boss = new Boss(x + tileSize / 2, y + tileSize / 2);
                        break;
                        
                    case '*': // Power-up spawn point
                        // Randomly select a power-up type
                        const powerUpTypeKeys = Object.keys(powerUpTypes);
                        const randomType = powerUpTypeKeys[Math.floor(Math.random() * powerUpTypeKeys.length)];
                        powerUps.push(new PowerUp(x + tileSize / 2, y + tileSize / 2, randomType));
                        break;
                }
            }
        }
        
        // Add random power-ups throughout the level
        for (let i = 0; i < 15; i++) {
            const x = Math.random() * (worldWidth - 100) + 50;
            const y = Math.random() * (worldHeight - 100) + 50;
            
            // Make sure power-up doesn't spawn inside a wall
            let validPosition = true;
            for (const wall of walls) {
                if (x > wall.x && x < wall.x + wall.width &&
                    y > wall.y && y < wall.y + wall.height) {
                    validPosition = false;
                    break;
                }
            }
            
            if (validPosition) {
                const powerUpTypeKeys = Object.keys(powerUpTypes);
                const randomType = powerUpTypeKeys[Math.floor(Math.random() * powerUpTypeKeys.length)];
                powerUps.push(new PowerUp(x, y, randomType));
            }
        }
        
        if (!playerSpawned) {
            console.warn('Player spawn point (P) not found in level layout!');
            player.x = offsetX + tileSize * 3 + tileSize / 2;
            player.y = offsetY + tileSize * 3 + tileSize / 2;
            console.log(`Player spawned at fallback position: ${player.x}, ${player.y}`);
        }
        
        // Ensure player position is valid
        if (isNaN(player.x) || isNaN(player.y)) {
            console.error('Player position is NaN! Setting to center of world.');
            player.x = worldWidth / 2;
            player.y = worldHeight / 2;
        }
        
        // Clamp player position to world bounds
        player.x = Math.max(player.size, Math.min(worldWidth - player.size, player.x));
        player.y = Math.max(player.size, Math.min(worldHeight - player.size, player.y));
        
        console.log(`Final player position: ${player.x}, ${player.y}`);
        
        for (const enemy of enemies) {
            const type = enemyTypes[enemy.type];
            Object.assign(enemy, {
                health: type.health,
                maxHealth: type.maxHealth,
                speed: type.speed,
                size: type.size,
                color: type.color,
                hasKnife: type.hasKnife,
                attackDamage: type.attackDamage,
                attackRange: type.attackRange,
                detectionRange: type.detectionRange,
                fireRate: type.fireRate || 60,
                canShootThroughWalls: type.canShootThroughWalls || false,
                bulletSpeed: type.bulletSpeed || 10,
                path: [],
                pathIndex: 0,
                pathUpdateCounter: 0,
                shouldFlash: false,
                forcePathUpdate: false,
                isCloaked: false,
                cloakTime: 0
            });
            
            if (enemy.type === 'shield') {
                enemy.hasShield = true;
                enemy.shieldHealth = type.shieldHealth;
                enemy.shieldMaxHealth = type.shieldMaxHealth;
            }
            
            // Initialize special enemy properties
            if (enemy.type === 'hacker') {
                enemy.hackCooldown = type.hackCooldown;
                enemy.lastHackTime = 0;
            } else if (enemy.type === 'cloaker') {
                enemy.cloakCooldown = type.cloakCooldown;
                enemy.lastCloakTime = 0;
            } else if (enemy.type === 'fire') {
                enemy.burnCooldown = type.burnCooldown;
                enemy.lastBurnTime = 0;
            } else if (enemy.type === 'electric') {
                enemy.shockCooldown = type.shockCooldown;
                enemy.lastShockTime = 0;
            }
            
            // Add enemy to its room
            if (enemy.room !== null) {
                const room = rooms.find(r => r.id === enemy.room);
                if (room) {
                    room.addEnemy(enemy);
                }
            }
        }
        
        // Initialize door wasBroken property
        for (const door of doors) {
            door.wasBroken = door.isBroken;
        }
        
        // Initialize quadtree pathfinder
        pathfinder = new QuadTree(worldWidth, worldHeight);
        pathfinder.buildTree(walls, doors);
        
        // Find spawn points for enemy spawning system
        findSpawnPoints();
    }
    
    function findSpawnPoints() {
        spawnPoints = [];
        
        // Check potential spawn locations throughout the level
        for (let x = 100; x < worldWidth - 100; x += 200) {
            for (let y = 100; y < worldHeight - 100; y += 200) {
                // Check if position is valid (not inside walls or too close to player)
                let validPosition = true;
                
                // Check walls
                for (const wall of walls) {
                    if (x > wall.x && x < wall.x + wall.width &&
                        y > wall.y && y < wall.y + wall.height) {
                        validPosition = false;
                        break;
                    }
                }
                
                // Check distance from player
                const dx = player.x - x;
                const dy = player.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 500) { // Don't spawn too close to player
                    validPosition = false;
                }
                
                if (validPosition) {
                    spawnPoints.push({x, y});
                }
            }
        }
        
        console.log(`Found ${spawnPoints.length} valid spawn points`);
    }
    
    function loadSounds() {
        // Create dummy sound objects to avoid errors
        soundManager.load('pistol', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('shotgun', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('sniper', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('enemyHit', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('enemyDeath', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('playerHit', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('doorBreak', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('portal', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('pickup', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
        soundManager.load('explosion', 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA');
    }
    
    // ========== LINE OF SIGHT FUNCTION ==========
    function hasLineOfSight(x1, y1, x2, y2) {
        // Check if there's a wall or unbroken door blocking the line between two points
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // We'll check in small steps along the line
        const steps = Math.ceil(distance / 10); // Check every 10 pixels
        const stepX = dx / steps;
        const stepY = dy / steps;
        
        for (let i = 1; i <= steps; i++) {
            const checkX = x1 + stepX * i;
            const checkY = y1 + stepY * i;
            
            // Check walls
            for (const wall of walls) {
                if (checkX >= wall.x && checkX <= wall.x + wall.width &&
                    checkY >= wall.y && checkY <= wall.y + wall.height) {
                    return false;
                }
            }
            
            // Check doors (only unbroken doors block)
            for (const door of doors) {
                if (!door.isBroken &&
                    checkX >= door.x && checkX <= door.x + door.width &&
                    checkY >= door.y && checkY <= door.y + door.height) {
                    return false;
                }
            }
        }
        
        return true;
    }
    
    // ========== CREATE EXPLOSION FUNCTION ==========
    function createExplosion(x, y, radius, damage = 50) {
        explosions.push(new Explosion(x, y, radius, damage));
    }
    
    // ========== CREATE BULLET IMPACT FUNCTION ==========
    function createBulletImpact(x, y, angle, weaponType) {
        // Create impact particles
        let particleCount = 5;
        let color = '#ffff00';
        
        if (weaponType === 'shotgun') {
            particleCount = 8;
            color = '#ff9900';
        } else if (weaponType === 'sniper') {
            particleCount = 15;
            color = '#00ffff';
        }
        
        for (let i = 0; i < particleCount; i++) {
            const spreadAngle = angle + (Math.random() - 0.5) * Math.PI / 2;
            const speed = Math.random() * 3 + 1;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(spreadAngle) * speed,
                vy: Math.sin(spreadAngle) * speed,
                size: Math.random() * 3 + 1,
                color: color,
                life: 20
            });
        }
        
        // Add screen shake for sniper
        if (weaponType === 'sniper') {
            shakeScreen(3);
        }
    }
    
    // ========== CREATE ENEMY HIT EFFECT FUNCTION ==========
    function createEnemyHitEffect(enemy, damage, isHeadshot = false) {
        // Create hit particles
        for (let i = 0; i < damage; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;
            particles.push({
                x: enemy.x,
                y: enemy.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * 2 + 1,
                color: isHeadshot ? '#ffff00' : '#ff0000',
                life: 15
            });
        }
        
        // Screen shake based on damage
        shakeScreen(damage / 5);
        
        // Brief enemy flash
        enemy.hitFlash = 5;
    }
    
    // ========== CREATE MUZZLE FLASH FUNCTION ==========
    function createMuzzleFlash(x, y, angle, color) {
        const flashDistance = 20;
        const flashX = x + Math.cos(angle) * flashDistance;
        const flashY = y + Math.sin(angle) * flashDistance;
        
        // Create flash particles
        for (let i = 0; i < 10; i++) {
            const spreadAngle = angle + (Math.random() - 0.5) * Math.PI / 4;
            const speed = Math.random() * 5 + 2;
            particles.push({
                x: flashX,
                y: flashY,
                vx: Math.cos(spreadAngle) * speed,
                vy: Math.sin(spreadAngle) * speed,
                size: Math.random() * 4 + 2,
                color: color,
                life: 10
            });
        }
    }
    
    // ========== CREATE KILL NOTIFICATION ==========
    function createKillNotification(x, y, killType) {
        // Find the appropriate notification based on kill type
        let notification = killNotifications[0]; // Default to "BRUTAL"
        
        if (killType === 'headshot') {
            notification = killNotifications.find(n => n.special === 'headshot') || notification;
        } else if (killType === 'execution') {
            notification = killNotifications[Math.min(killStreak, killNotifications.length - 1)];
        } else {
            // Select based on combo streak
            notification = killNotifications[Math.min(combo - 1, killNotifications.length - 1)];
        }
        
        // Create the notification
        floatingTexts.push(new FloatingText(
            x, 
            y - 30, 
            notification.text, 
            notification.color,
            24,
            0.5
        ));
        
        // Screen effects for high-level kills
        if (combo >= 5) {
            camera.flashIntensity = 10;
            shakeScreen(5);
        }
        
        if (combo >= 8) {
            camera.chromaticAberration = 10;
        }
        
        if (combo >= 10) {
            camera.vhsLines = true;
            setTimeout(() => { camera.vhsLines = false; }, 1000);
        }
    }
    
    // ========== UPDATE FUNCTIONS ==========
    function updatePlayer() {
        if (player.isDead) return;
        
        // Update power-up timers
        for (const effect in player.powerUpTimers) {
            if (player.powerUpTimers[effect] > 0) {
                player.powerUpTimers[effect]--;
                
                // Reset effect when timer expires
                if (player.powerUpTimers[effect] === 0) {
                    switch (effect) {
                        case 'speed':
                            player.speedMultiplier = 1;
                            break;
                        case 'rapidFire':
                            player.fireRateMultiplier = 1;
                            break;
                        case 'damage':
                            player.damageMultiplier = 1;
                            break;
                        case 'invulnerability':
                            player.invulnerable = false;
                            break;
                    }
                }
            }
        }
        
        // Handle status effects
        if (player.isFrozen) {
            player.frozenTime--;
            if (player.frozenTime <= 0) {
                player.isFrozen = false;
                statusEffectsSurvived++;
                checkAchievements();
                floatingTexts.push(new FloatingText(
                    player.x, 
                    player.y - player.size - 20, 
                    'UNFROZEN!', 
                    '#00ffff'
                ));
            }
        }
        
        if (player.isBurning) {
            player.burnTime--;
            player.burnDamageTimer--;
            
            if (player.burnDamageTimer <= 0) {
                player.health -= enemyTypes.fire.burnDamage;
                player.burnDamageTimer = 30; // Reset timer
                
                createParticles(player.x, player.y, '#ff5500', 5, 2);
                updateHUD();
                
                if (player.health <= 0) {
                    playerDeath();
                }
            }
            
            if (player.burnTime <= 0) {
                player.isBurning = false;
                statusEffectsSurvived++;
                checkAchievements();
                floatingTexts.push(new FloatingText(
                    player.x, 
                    player.y - player.size - 20, 
                    'EXTINGUISHED!', 
                    '#ff5500'
                ));
            }
        }
        
        if (player.isShocked) {
            player.shockedTime--;
            
            if (player.shockedTime <= 0) {
                player.isShocked = false;
                statusEffectsSurvived++;
                checkAchievements();
                floatingTexts.push(new FloatingText(
                    player.x, 
                    player.y - player.size - 20, 
                    'SHOCK ENDED!', 
                    '#ffff00'
                ));
            }
        }
        
        if (player.isHacked) {
            player.hackedTime--;
            
            if (player.hackedTime <= 0) {
                player.isHacked = false;
                statusEffectsSurvived++;
                checkAchievements();
                floatingTexts.push(new FloatingText(
                    player.x, 
                    player.y - player.size - 20, 
                    'SYSTEM RESTORED!', 
                    '#00ff88'
                ));
            }
        }
        
        // Handle invulnerability from power-up
        if (player.powerUpTimers.invulnerability > 0) {
            player.invulnerable = true;
        }
        
        // Weapon switching
        if (keys['1']) {
            player.currentWeapon = 'pistol';
            keys['1'] = false;
        }
        if (keys['2']) {
            player.currentWeapon = 'shotgun';
            keys['2'] = false;
        }
        if (keys['3']) {
            player.currentWeapon = 'sniper';
            keys['3'] = false;
        }
        if (keys['4']) {
            player.currentWeapon = 'melee';
            keys['4'] = false;
        }
        
        // Reloading
        if (keys['r'] && !player.isReloading && player.currentWeapon !== 'melee') {
            const weapon = player.currentWeapon;
            if (weapon === 'pistol' && player.pistolAmmo < weaponProperties.pistol.maxAmmo) {
                player.isReloading = true;
                player.reloadTime = weaponProperties.pistol.reloadTime;
            } else if (weapon === 'shotgun' && player.shotgunAmmo < weaponProperties.shotgun.maxAmmo) {
                player.isReloading = true;
                player.reloadTime = weaponProperties.shotgun.reloadTime;
            } else if (weapon === 'sniper' && player.sniperAmmo < weaponProperties.sniper.maxAmmo) {
                player.isReloading = true;
                player.reloadTime = weaponProperties.sniper.reloadTime;
            }
        }
        
        // Weapon actions
        if (keys['c'] && player.currentWeapon === 'shotgun' && !player.isShotgunCocked) {
            player.isShotgunCocked = true;
            createParticles(player.x, player.y, '#ff9900', 5, 2);
        }
        
        if (keys['v'] && player.currentWeapon === 'sniper' && !player.isSniperReady) {
            player.isSniperReady = true;
            createParticles(player.x, player.y, '#00ffff', 5, 2);
        }
        
        if (keys['f'] && player.kickCooldown === 0) {
            playerKick();
            player.kickCooldown = 30;
        }
        
        // Sound toggle
        if (keys['m']) {
            soundManager.toggle();
            keys['m'] = false;
            floatingTexts.push(new FloatingText(
                player.x, 
                player.y - player.size - 20, 
                `Sound ${soundManager.enabled ? 'ON' : 'OFF'}`, 
                '#ffffff',
                16
            ));
        }
        
        // VHS lines toggle
        if (keys['v'] && keys['shift']) {
            camera.vhsLines = !camera.vhsLines;
            keys['v'] = false;
            keys['shift'] = false;
        }
        
        // Update reloading
        if (player.isReloading) {
            player.reloadTime--;
            if (player.reloadTime <= 0) {
                const weapon = player.currentWeapon;
                if (weapon === 'pistol') {
                    player.pistolAmmo = weaponProperties.pistol.maxAmmo;
                } else if (weapon === 'shotgun') {
                    player.shotgunAmmo = weaponProperties.shotgun.maxAmmo;
                } else if (weapon === 'sniper') {
                    player.sniperAmmo = weaponProperties.sniper.maxAmmo;
                }
                player.isReloading = false;
            }
        }
        
        // Update cooldowns
        if (player.kickCooldown > 0) player.kickCooldown--;
        
        if (player.invulnerable && player.powerUpTimers.invulnerability === 0) {
            player.invulnerableTime--;
            if (player.invulnerableTime <= 0) {
                player.invulnerable = false;
            }
        }
        
        // Player can't move while frozen or executing
        if (player.isFrozen || player.isExecuting) return;
        
        // Movement
        let dx = 0, dy = 0;
        if (keys['w']) dy -= player.speed * player.speedMultiplier;
        if (keys['s']) dy += player.speed * player.speedMultiplier;
        if (keys['a']) dx -= player.speed * player.speedMultiplier;
        if (keys['d']) dx += player.speed * player.speedMultiplier;
        
        if (dx !== 0 && dy !== 0) {
            dx *= 0.707;
            dy *= 0.707;
        }
        
        const newX = player.x + dx;
        const newY = player.y + dy;
        
        let canMoveX = true;
        let canMoveY = true;
        
        // Check collision with walls
        for (const wall of walls) {
            if (newX - player.size < wall.x + wall.width &&
                newX + player.size > wall.x &&
                player.y - player.size < wall.y + wall.height &&
                player.y + player.size > wall.y) {
                canMoveX = false;
            }
            
            if (player.x - player.size < wall.x + wall.width &&
                player.x + player.size > wall.x &&
                newY - player.size < wall.y + wall.height &&
                newY + player.size > wall.y) {
                canMoveY = false;
            }
        }
        
        // Check collision with doors
        for (const door of doors) {
            if (!door.isBroken) {
                if (newX - player.size < door.x + door.width &&
                    newX + player.size > door.x &&
                    player.y - player.size < door.y + door.height &&
                    player.y + player.size > door.y) {
                    canMoveX = false;
                }
                
                if (player.x - player.size < door.x + door.width &&
                    player.x + player.size > door.x &&
                    newY - player.size < door.y + door.height &&
                    newY + player.size > door.y) {
                    canMoveY = false;
                }
            }
        }
        
        if (canMoveX) player.x = newX;
        if (canMoveY) player.y = newY;
        
        // Clamp player position to world bounds
        player.x = Math.max(player.size, Math.min(worldWidth - player.size, player.x));
        player.y = Math.max(player.size, Math.min(worldHeight - player.size, player.y));
        
        // Update player angle
        const mouseWorldX = mouse.x + camera.x;
        const mouseWorldY = mouse.y + camera.y;
        player.angle = Math.atan2(mouseWorldY - player.y, mouseWorldX - player.x);
        
        // Update shoot cooldown
        if (player.shootCooldown > 0) player.shootCooldown--;
        
        // Update muzzle flash
        if (player.muzzleFlash > 0) {
            player.muzzleFlash--;
        }
        
        // Update recoil
        if (player.recoilAngle !== 0) {
            player.recoilAngle *= 0.9;
            if (Math.abs(player.recoilAngle) < 0.01) {
                player.recoilAngle = 0;
            }
        }
        
        // Check for execution opportunities
        checkExecutionOpportunity();
        
        // Update current room
        updateCurrentRoom();
    }
    
    function updateCurrentRoom() {
        // Find which room the player is currently in
        let newRoom = null;
        for (const room of rooms) {
            if (room.contains(player.x, player.y)) {
                newRoom = room;
                break;
            }
        }
        
        // If player changed rooms
        if (newRoom && newRoom !== currentRoom) {
            // Lock doors in the previous room
            if (currentRoom && currentRoom.state === roomStates.UNLOCKED) {
                for (const door of currentRoom.doors) {
                    door.isLocked = true;
                }
            }
            
            // Unlock doors in the new room
            if (newRoom.state === roomStates.LOCKED) {
                newRoom.state = roomStates.UNLOCKED;
                for (const door of newRoom.doors) {
                    door.isLocked = false;
                }
                
                // Show room entered notification
                floatingTexts.push(new FloatingText(
                    newRoom.x + newRoom.width / 2, 
                    newRoom.y + newRoom.height / 2, 
                    `ROOM ${newRoom.id} ENTERED`, 
                    '#ffff00',
                    24,
                    0.5
                ));
            }
            
            currentRoom = newRoom;
        }
    }
    
    function checkExecutionOpportunity() {
        player.canExecute = false;
        player.executionTarget = null;
        
        // Check for enemies that can be executed
        for (const enemy of enemies) {
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Enemy can be executed if:
            // 1. Health is below 30% of max health
            // 2. Player is close enough
            // 3. Player is using melee weapon or has no ammo
            if (enemy.health / enemy.maxHealth <= 0.3 && 
                distance < enemy.size + player.size + 10 &&
                (player.currentWeapon === 'melee' || 
                 (player.currentWeapon === 'pistol' && player.pistolAmmo === 0) ||
                 (player.currentWeapon === 'shotgun' && player.shotgunAmmo === 0) ||
                 (player.currentWeapon === 'sniper' && player.sniperAmmo === 0))) {
                player.canExecute = true;
                player.executionTarget = enemy;
                break;
            }
        }
    }
    
    function executeEnemy(enemy) {
        if (!enemy || player.isExecuting) return;
        
        player.isExecuting = true;
        executionKills++;
        
        // Create execution effect
        createBloodSplatter(enemy.x, enemy.y, 15);
        shakeScreen(10);
        camera.flashIntensity = 15;
        
        // Show execution notification
        createKillNotification(enemy.x, enemy.y, 'execution');
        
        // Award points
        const points = enemyTypes[enemy.type].points * 2; // Double points for execution
        score += points;
        
        floatingTexts.push(new FloatingText(
            enemy.x, 
            enemy.y - enemy.size, 
            `+${points} EXECUTION!`, 
            '#ff0000',
            20
        ));
        
        // Remove the enemy
        const enemyIndex = enemies.indexOf(enemy);
        if (enemyIndex !== -1) {
            enemies.splice(enemyIndex, 1);
            kills++;
            
            // Update combo
            const now = Date.now();
            if (now - lastKillTime < 2000) {
                combo++;
            } else {
                combo = 1;
            }
            lastKillTime = now;
            
            updateHUD();
            checkAchievements();
        }
        
        // End execution after a short delay
        setTimeout(() => {
            player.isExecuting = false;
            player.executionTarget = null;
        }, 500);
    }
    
    function updateCamera() {
        if (camera.x === 0 && camera.y === 0) {
            camera.x = player.x - camera.width / 2;
            camera.y = player.y - camera.height / 2;
            
            camera.x = Math.max(0, Math.min(worldWidth - camera.width, camera.x));
            camera.y = Math.max(0, Math.min(worldHeight - camera.height, camera.y));
            
            console.log(`Camera initialized at: ${camera.x}, ${camera.y}`);
            return;
        }
        
        const targetX = player.x - camera.width / 2;
        const targetY = player.y - camera.height / 2;
        
        camera.x += (targetX - camera.x) * camera.followSpeed;
        camera.y += (targetY - camera.y) * camera.followSpeed;
        
        camera.x = Math.max(0, Math.min(worldWidth - camera.width, camera.x));
        camera.y = Math.max(0, Math.min(worldHeight - camera.height, camera.y));
        
        // Update screen effects
        if (camera.flashIntensity > 0) {
            camera.flashIntensity--;
        }
        
        if (camera.glitchIntensity > 0) {
            camera.glitchIntensity--;
        }
        
        if (camera.chromaticAberration > 0) {
            camera.chromaticAberration--;
        }
    }
    
    function updateEnemies() {
        // Update pathfinder if any door was broken
        let doorBroken = false;
        for (const door of doors) {
            if (!door.wasBroken && door.isBroken) {
                door.wasBroken = true;
                doorBroken = true;
                doorsDestroyed++;
                checkAchievements();
            }
        }
        
        if (doorBroken) {
            try {
                // Completely rebuild the pathfinder when a door breaks
                pathfinder = new QuadTree(worldWidth, worldHeight);
                pathfinder.buildTree(walls, doors);
                
                // Force all enemies to recalculate their paths
                for (const enemy of enemies) {
                    enemy.forcePathUpdate = true;
                    enemy.path = [];
                    enemy.pathUpdateCounter = 0; // Force immediate recalculation
                }
            } catch (error) {
                console.error("Error updating pathfinder:", error);
                // Fallback: clear all paths without crashing
                for (const enemy of enemies) {
                    enemy.path = [];
                }
            }
        }
        
        for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            const dx = player.x - enemy.x;
            const dy = player.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Update hit flash
            if (enemy.hitFlash > 0) {
                enemy.hitFlash--;
            }
            
            // Handle special enemy abilities
            if (enemy.type === 'hacker' && distance < enemy.detectionRange) {
                // Hacker attack - disable player's weapons
                if (enemy.hackCooldown > 0) {
                    enemy.hackCooldown--;
                } else if (distance < enemy.attackRange) {
                    // Hack the player
                    enemy.hackCooldown = enemyTypes.hacker.hackCooldown;
                    player.isHacked = true;
                    player.hackedTime = enemyTypes.hacker.hackDuration;
                    
                    // Create hack effect
                    for (let i = 0; i < 20; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 3 + 1;
                        particles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: Math.random() * 3 + 1,
                            color: '#00ff88',
                            life: 20
                        });
                    }
                    
                    // Glitch effect
                    camera.glitchIntensity = 30;
                    
                    floatingTexts.push(new FloatingText(
                        player.x, 
                        player.y - player.size - 20, 
                        'SYSTEM HACKED!', 
                        '#00ff88'
                    ));
                }
            }
            
            if (enemy.type === 'cloaker') {
                // Cloaker ability - turn invisible
                if (enemy.cloakCooldown > 0) {
                    enemy.cloakCooldown--;
                } else if (!enemy.isCloaked && distance > enemy.attackRange * 2) {
                    // Cloak the enemy
                    enemy.cloakCooldown = enemyTypes.cloaker.cloakCooldown;
                    enemy.isCloaked = true;
                    enemy.cloakTime = enemyTypes.cloaker.cloakDuration;
                    
                    // Create cloak effect
                    createParticles(enemy.x, enemy.y, '#aa00ff', 15, 3);
                }
                
                // Update cloak
                if (enemy.isCloaked) {
                    enemy.cloakTime--;
                    
                    if (enemy.cloakTime <= 0) {
                        enemy.isCloaked = false;
                        
                        // Create uncloak effect
                        createParticles(enemy.x, enemy.y, '#aa00ff', 15, 3);
                    }
                }
            }
            
            if (enemy.type === 'fire' && distance < enemy.attackRange && enemy.burnCooldown <= 0) {
                // Fire burn ability
                enemy.burnCooldown = enemyTypes.fire.burnCooldown;
                player.isBurning = true;
                player.burnTime = enemyTypes.fire.burnDuration;
                player.burnDamageTimer = 30;
                
                createParticles(player.x, player.y, '#ff5500', 20, 3);
                floatingTexts.push(new FloatingText(
                    player.x, 
                    player.y - player.size - 20, 
                    'BURNING!', 
                    '#ff5500'
                ));
            }
            
            if (enemy.type === 'electric' && distance < enemy.attackRange && enemy.shockCooldown <= 0) {
                // Electric shock ability
                enemy.shockCooldown = enemyTypes.electric.shockCooldown;
                player.isShocked = true;
                player.shockedTime = 60;
                
                // Create shock effect
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const shockX = player.x + Math.cos(angle) * enemyTypes.electric.shockRadius;
                    const shockY = player.y + Math.sin(angle) * enemyTypes.electric.shockRadius;
                    
                    createParticles(shockX, shockY, '#ffff00', 5, 2);
                }
                
                // Apply shock damage
                player.health -= enemyTypes.electric.shockDamage;
                createBloodSplatter(player.x, player.y, 5);
                shakeScreen(10);
                updateHUD();
                
                floatingTexts.push(new FloatingText(
                    player.x, 
                    player.y - player.size - 20, 
                    'SHOCKED!', 
                    '#ffff00'
                ));
                
                if (player.health <= 0) {
                    playerDeath();
                }
            }
            
            if (distance < enemy.detectionRange) {
                // Check if there's a clear line of sight to the player
                const hasClearPath = hasLineOfSight(enemy.x, enemy.y, player.x, player.y);
                
                if (hasClearPath) {
                    // Use direct movement when there's a clear path
                    const dirX = dx / distance;
                    const dirY = dy / distance;
                    
                    let moveX = dirX * enemy.speed;
                    let moveY = dirY * enemy.speed;
                    
                    // Check collision with walls and doors separately for X and Y
                    let canMoveX = true;
                    let canMoveY = true;
                    
                    // Test X movement
                    const testX = enemy.x + moveX;
                    for (const wall of walls) {
                        if (testX - enemy.size < wall.x + wall.width &&
                            testX + enemy.size > wall.x &&
                            enemy.y - enemy.size < wall.y + wall.height &&
                            enemy.y + enemy.size > wall.y) {
                            canMoveX = false;
                            break;
                        }
                    }
                    
                    if (canMoveX) {
                        for (const door of doors) {
                            if (!door.isBroken &&
                                testX - enemy.size < door.x + door.width &&
                                testX + enemy.size > door.x &&
                                enemy.y - enemy.size < door.y + door.height &&
                                enemy.y + enemy.size > door.y) {
                                canMoveX = false;
                                
                                // Attack door if close
                                const doorDist = Math.sqrt(
                                    Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                    Math.pow(enemy.y - (door.y + door.height/2), 2)
                                );
                                
                                if (doorDist < enemy.size + 20) {
                                    door.health--;
                                    createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                    
                                    if (door.health <= 0) {
                                        door.isBroken = true;
                                        createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                        shakeScreen(5);
                                        soundManager.play('doorBreak');
                                    }
                                }
                                break;
                            }
                        }
                    }
                    
                    // Test Y movement
                    const testY = enemy.y + moveY;
                    for (const wall of walls) {
                        if (enemy.x - enemy.size < wall.x + wall.width &&
                            enemy.x + enemy.size > wall.x &&
                            testY - enemy.size < wall.y + wall.height &&
                            testY + enemy.size > wall.y) {
                            canMoveY = false;
                            break;
                        }
                    }
                    
                    if (canMoveY) {
                        for (const door of doors) {
                            if (!door.isBroken &&
                                enemy.x - enemy.size < door.x + door.width &&
                                enemy.x + enemy.size > door.x &&
                                testY - enemy.size < door.y + door.height &&
                                testY + enemy.size > door.y) {
                                canMoveY = false;
                                
                                // Attack door if close
                                const doorDist = Math.sqrt(
                                    Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                    Math.pow(enemy.y - (door.y + door.height/2), 2)
                                );
                                
                                if (doorDist < enemy.size + 20) {
                                    door.health--;
                                    createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                    
                                    if (door.health <= 0) {
                                        door.isBroken = true;
                                        createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                        shakeScreen(5);
                                        soundManager.play('doorBreak');
                                    }
                                }
                                break;
                            }
                        }
                    }
                    
                    // Move if no collision
                    if (canMoveX) enemy.x += moveX;
                    if (canMoveY) enemy.y += moveY;
                    
                    // Update enemy angle to face player
                    enemy.angle = Math.atan2(dy, dx);
                } else {
                    // Use pathfinding when obstacles are in the way
                    enemy.pathUpdateCounter--;
                    
                    // Check if we need a new path
                    const playerMovedSignificantly = enemy.lastPlayerX && enemy.lastPlayerY && 
                        (Math.abs(player.x - enemy.lastPlayerX) > 150 || 
                         Math.abs(player.y - enemy.lastPlayerY) > 150);
                    
                    if (enemy.pathUpdateCounter <= 0 || !enemy.path || enemy.path.length === 0 || 
                        enemy.forcePathUpdate || playerMovedSignificantly) {
                        
                        try {
                            // Find path using quadtree
                            const newPath = pathfinder.findPath(enemy.x, enemy.y, player.x, player.y);
                            
                            if (newPath && newPath.length > 0) {
                                enemy.path = newPath;
                                enemy.pathIndex = 0;
                                enemy.pathUpdateCounter = 30; // Update path every 30 frames
                                enemy.forcePathUpdate = false;
                                
                                // Store current player position
                                enemy.lastPlayerX = player.x;
                                enemy.lastPlayerY = player.y;
                                
                                // Initialize stuck counter if not exists
                                if (!enemy.pathStuckCounter) {
                                    enemy.pathStuckCounter = 30;
                                    enemy.lastPosition = { x: enemy.x, y: enemy.y };
                                }
                            } else {
                                // If no path found, clear path to use direct movement
                                enemy.path = [];
                            }
                        } catch (error) {
                            console.error("Pathfinding error:", error);
                            enemy.path = []; // Clear path on error
                        }
                    }
                    
                    // Move along path if available
                    if (enemy.path && enemy.path.length > 0 && enemy.pathIndex < enemy.path.length) {
                        const targetPoint = enemy.path[enemy.pathIndex];
                        
                        // Calculate direction to target point
                        const dirX = targetPoint.x - enemy.x;
                        const dirY = targetPoint.y - enemy.y;
                        const dirDistance = Math.sqrt(dirX * dirX + dirY * dirY);
                        
                        // If close enough to current point, move to next point
                        if (dirDistance < 25) {
                            enemy.pathIndex++;
                            if (enemy.pathIndex >= enemy.path.length) {
                                // Reached end of path, try to get closer to player directly
                                enemy.path = [];
                            }
                        } else {
                            // Normalize direction and apply speed
                            const moveX = (dirX / dirDistance) * enemy.speed;
                            const moveY = (dirY / dirDistance) * enemy.speed;
                            
                            // Check collision with walls and doors separately for X and Y
                            let canMoveX = true;
                            let canMoveY = true;
                            
                            // Test X movement
                            const testX = enemy.x + moveX;
                            for (const wall of walls) {
                                if (testX - enemy.size < wall.x + wall.width &&
                                    testX + enemy.size > wall.x &&
                                    enemy.y - enemy.size < wall.y + wall.height &&
                                    enemy.y + enemy.size > wall.y) {
                                    canMoveX = false;
                                    break;
                                }
                            }
                            
                            if (canMoveX) {
                                for (const door of doors) {
                                    if (!door.isBroken &&
                                        testX - enemy.size < door.x + door.width &&
                                        testX + enemy.size > door.x &&
                                        enemy.y - enemy.size < door.y + door.height &&
                                        enemy.y + enemy.size > door.y) {
                                        canMoveX = false;
                                        
                                        // Attack door if close
                                        const doorDist = Math.sqrt(
                                            Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                            Math.pow(enemy.y - (door.y + door.height/2), 2)
                                        );
                                        
                                        if (doorDist < enemy.size + 20) {
                                            door.health--;
                                            createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                            
                                            if (door.health <= 0) {
                                                door.isBroken = true;
                                                createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                                shakeScreen(5);
                                                soundManager.play('doorBreak');
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            
                            // Test Y movement
                            const testY = enemy.y + moveY;
                            for (const wall of walls) {
                                if (enemy.x - enemy.size < wall.x + wall.width &&
                                    enemy.x + enemy.size > wall.x &&
                                    testY - enemy.size < wall.y + wall.height &&
                                    testY + enemy.size > wall.y) {
                                    canMoveY = false;
                                    break;
                                }
                            }
                            
                            if (canMoveY) {
                                for (const door of doors) {
                                    if (!door.isBroken &&
                                        enemy.x - enemy.size < door.x + door.width &&
                                        enemy.x + enemy.size > door.x &&
                                        testY - enemy.size < door.y + door.height &&
                                        testY + enemy.size > door.y) {
                                        canMoveY = false;
                                        
                                        // Attack door if close
                                        const doorDist = Math.sqrt(
                                            Math.pow(enemy.x - (door.x + door.width/2), 2) + 
                                            Math.pow(enemy.y - (door.y + door.height/2), 2)
                                        );
                                        
                                        if (doorDist < enemy.size + 20) {
                                            door.health--;
                                            createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 10, 3);
                                            
                                            if (door.health <= 0) {
                                                door.isBroken = true;
                                                createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                                                shakeScreen(5);
                                                soundManager.play('doorBreak');
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            
                            // Move if no collision
                            if (canMoveX) enemy.x += moveX;
                            if (canMoveY) enemy.y += moveY;
                            
                            // Check if enemy actually moved (not stuck)
                            if (enemy.lastPosition) {
                                const distFromLastPos = Math.sqrt(
                                    Math.pow(enemy.x - enemy.lastPosition.x, 2) + 
                                    Math.pow(enemy.y - enemy.lastPosition.y, 2)
                                );
                                
                                if (distFromLastPos < 0.5) { // If barely moved
                                    enemy.pathStuckCounter--;
                                    if (enemy.pathStuckCounter <= 0) {
                                        // Enemy is stuck, force path recalculation
                                        enemy.forcePathUpdate = true;
                                        enemy.path = [];
                                        enemy.pathStuckCounter = 30; // Reset counter
                                    }
                                } else {
                                    // Enemy is moving, reset stuck counter
                                    enemy.pathStuckCounter = 30;
                                    enemy.lastPosition = { x: enemy.x, y: enemy.y };
                                }
                            }
                        }
                    } else if (!enemy.path || enemy.path.length === 0) {
                        // If no path, try direct movement (simple approach)
                        const dirX = player.x - enemy.x;
                        const dirY = player.y - enemy.y;
                        const dirDistance = Math.sqrt(dirX * dirX + dirY * dirY);
                        
                        if (dirDistance > 0) {
                            const moveX = (dirX / dirDistance) * enemy.speed;
                            const moveY = (dirY / dirDistance) * enemy.speed;
                            
                            let canMoveX = true;
                            let canMoveY = true;
                            const testX = enemy.x + moveX;
                            const testY = enemy.y + moveY;
                            
                            // Check collision with walls
                            for (const wall of walls) {
                                if (testX - enemy.size < wall.x + wall.width &&
                                    testX + enemy.size > wall.x &&
                                    enemy.y - enemy.size < wall.y + wall.height &&
                                    enemy.y + enemy.size > wall.y) {
                                    canMoveX = false;
                                }
                                
                                if (enemy.x - enemy.size < wall.x + wall.width &&
                                    enemy.x + enemy.size > wall.x &&
                                    testY - enemy.size < wall.y + wall.height &&
                                    testY + enemy.size > wall.y) {
                                    canMoveY = false;
                                }
                            }
                            
                            // Check collision with doors
                            for (const door of doors) {
                                if (!door.isBroken) {
                                    if (testX - enemy.size < door.x + door.width &&
                                        testX + enemy.size > door.x &&
                                        enemy.y - enemy.size < door.y + door.height &&
                                        enemy.y + enemy.size > door.y) {
                                        canMoveX = false;
                                    }
                                    
                                    if (enemy.x - enemy.size < door.x + door.width &&
                                        enemy.x + enemy.size > door.x &&
                                        testY - enemy.size < door.y + door.height &&
                                        testY + enemy.size > door.y) {
                                        canMoveY = false;
                                    }
                                }
                            }
                            
                            if (canMoveX) enemy.x += moveX;
                            if (canMoveY) enemy.y += moveY;
                        }
                    }
                    
                    // Update enemy angle to face player
                    enemy.angle = Math.atan2(dy, dx);
                }
                
                // Handle enemy attacks
                if (enemy.type === 'suicide' && distance < enemy.attackRange) {
                    // Flash faster as it gets closer to exploding
                    const flashRate = Math.max(1, Math.floor(enemy.attackCooldown / enemyTypes.suicide.flashRate));
                    enemy.shouldFlash = (flashRate % 2 === 0);
                    
                    if (enemy.attackCooldown <= 0) {
                        // Create explosion when suicide enemy reaches player
                        createExplosion(enemy.x, enemy.y, enemy.explosionRadius, enemy.attackDamage);
                        
                        // Remove the enemy
                        enemies.splice(j, 1);
                        continue;
                    }
                }
                
                if (enemy.type === 'spawner' && enemy.canSpawn && enemy.spawnCooldown <= 0) {
                    const angle = Math.random() * Math.PI * 2;
                    const spawnX = enemy.x + Math.cos(angle) * enemy.spawnRadius;
                    const spawnY = enemy.y + Math.sin(angle) * enemy.spawnRadius;
                    
                    enemies.push({
                        x: spawnX,
                        y: spawnY,
                        type: 'basic',
                        angle: 0,
                        attackCooldown: 0,
                        room: enemy.room
                    });
                    
                    const newEnemy = enemies[enemies.length - 1];
                    const type = enemyTypes['basic'];
                    Object.assign(newEnemy, {
                        health: type.health,
                        maxHealth: type.maxHealth,
                        speed: type.speed,
                        size: type.size,
                        color: type.color,
                        hasKnife: type.hasKnife,
                        attackDamage: type.attackDamage,
                        attackRange: type.attackRange,
                        detectionRange: type.detectionRange,
                        fireRate: type.fireRate || 60,
                        canShootThroughWalls: type.canShootThroughWalls || false,
                        bulletSpeed: type.bulletSpeed || 10,
                        path: [],
                        pathIndex: 0,
                        pathUpdateCounter: 0,
                        shouldFlash: false,
                        forcePathUpdate: false
                    });
                    
                    // Add new enemy to room
                    if (newEnemy.room !== null) {
                        const room = rooms.find(r => r.id === newEnemy.room);
                        if (room) {
                            room.addEnemy(newEnemy);
                        }
                    }
                    
                    enemy.spawnCooldown = 180;
                    createParticles(spawnX, spawnY, '#9933ff', 20, 3);
                }
                
                if (enemy.type === 'basic' || enemy.type === 'heavy' || enemy.type === 'shield' || enemy.type === 'cloaker') {
                    if (enemy.hasKnife && distance < enemy.attackRange) {
                        if (enemy.attackCooldown <= 0) {
                            enemyAttack(enemy);
                            enemy.attackCooldown = 60;
                        }
                    }
                } else if (enemy.type === 'sniper' || enemy.type === 'hacker' || enemy.type === 'fire' || enemy.type === 'electric') {
                    if (distance < enemy.attackRange && enemy.attackCooldown <= 0) {
                        enemyShoot(enemy);
                        enemy.attackCooldown = enemy.fireRate;
                    }
                }
                
                if (enemy.attackCooldown > 0) enemy.attackCooldown--;
                if (enemy.spawnCooldown > 0) enemy.spawnCooldown--;
            }
        }
        
        // Check if rooms are cleared
        for (const room of rooms) {
            room.checkCleared();
            if (room.state === roomStates.CLEARED && room.clearedTime === Date.now()) {
                roomsCleared++;
                room.clearedTime = 1; // Set to 1 to avoid counting again
            }
        }
    }
    
    function updateEnemySpawning() {
        enemySpawnTimer++;
        
        // Update difficulty based on score
        updateDifficulty();
        
        if (enemySpawnTimer >= enemySpawnInterval && enemies.length < maxEnemies) {
            enemySpawnTimer = 0;
            
            // Find spawn points if we haven't already
            if (spawnPoints.length === 0) {
                findSpawnPoints();
            }
            
            if (spawnPoints.length > 0) {
                // Pick a random spawn point
                const spawnPoint = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
                
                // Determine enemy type based on difficulty level
                let enemyType = 'basic';
                const rand = Math.random();
                
                if (difficultyLevel >= 3) {
                    if (rand < 0.2) enemyType = 'heavy';
                    else if (rand < 0.4) enemyType = 'sniper';
                    else if (rand < 0.5) enemyType = 'shield';
                    else if (rand < 0.65) enemyType = 'cloaker';
                    else if (rand < 0.8) enemyType = 'hacker';
                    else if (rand < 0.9) enemyType = 'fire';
                    else enemyType = 'electric';
                } else if (difficultyLevel >= 2) {
                    if (rand < 0.3) enemyType = 'heavy';
                    else if (rand < 0.5) enemyType = 'sniper';
                    else if (rand < 0.7) enemyType = 'shield';
                    else if (rand < 0.85) enemyType = 'cloaker';
                    else enemyType = 'basic';
                } else if (difficultyLevel >= 1) {
                    if (rand < 0.4) enemyType = 'heavy';
                    else if (rand < 0.6) enemyType = 'sniper';
                    else enemyType = 'basic';
                }
                
                // Create the enemy
                enemies.push({ 
                    x: spawnPoint.x, 
                    y: spawnPoint.y, 
                    type: enemyType, 
                    angle: 0, 
                    attackCooldown: 0,
                    room: null // Spawned enemies don't belong to a room
                });
                
                // Initialize enemy properties
                const newEnemy = enemies[enemies.length - 1];
                const type = enemyTypes[enemyType];
                Object.assign(newEnemy, {
                    health: type.health,
                    maxHealth: type.maxHealth,
                    speed: type.speed,
                    size: type.size,
                    color: type.color,
                    hasKnife: type.hasKnife,
                    attackDamage: type.attackDamage,
                    attackRange: type.attackRange,
                    detectionRange: type.detectionRange,
                    fireRate: type.fireRate || 60,
                    canShootThroughWalls: type.canShootThroughWalls || false,
                    bulletSpeed: type.bulletSpeed || 10,
                    path: [],
                    pathIndex: 0,
                    pathUpdateCounter: 0,
                    shouldFlash: false,
                    forcePathUpdate: false,
                    isCloaked: false,
                    cloakTime: 0
                });
                
                // Initialize special enemy properties
                if (enemyType === 'shield') {
                    newEnemy.hasShield = true;
                    newEnemy.shieldHealth = type.shieldHealth;
                    newEnemy.shieldMaxHealth = type.shieldMaxHealth;
                } else if (enemyType === 'hacker') {
                    newEnemy.hackCooldown = type.hackCooldown;
                    newEnemy.lastHackTime = 0;
                } else if (enemyType === 'cloaker') {
                    newEnemy.cloakCooldown = type.cloakCooldown;
                    newEnemy.lastCloakTime = 0;
                } else if (enemyType === 'fire') {
                    newEnemy.burnCooldown = type.burnCooldown;
                    newEnemy.lastBurnTime = 0;
                } else if (enemyType === 'electric') {
                    newEnemy.shockCooldown = type.shockCooldown;
                    newEnemy.lastShockTime = 0;
                }
                
                // Create spawn effect
                createParticles(spawnPoint.x, spawnPoint.y, '#ff0000', 20, 5);
                
                // Show spawn notification
                floatingTexts.push(new FloatingText(
                    spawnPoint.x, 
                    spawnPoint.y - 20, 
                    `${enemyType.toUpperCase()} SPAWNED!`, 
                    enemyTypes[enemyType].color,
                    16
                ));
            }
        }
    }
    
    function updateDifficulty() {
        // Increase difficulty based on score
        if (score > 5000) {
            difficultyLevel = 3;
            enemySpawnInterval = 150; // Spawn every 2.5 seconds
            maxEnemies = 40;
        } else if (score > 3000) {
            difficultyLevel = 2;
            enemySpawnInterval = 240; // Spawn every 4 seconds
            maxEnemies = 35;
        } else if (score > 1000) {
            difficultyLevel = 1;
            enemySpawnInterval = 300; // Spawn every 5 seconds
            maxEnemies = 30;
        }
    }
    
    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            
            bullet.x += Math.cos(bullet.angle) * bullet.speed;
            bullet.y += Math.sin(bullet.angle) * bullet.speed;
            bullet.distance += bullet.speed;
            
            if (bullet.distance > bullet.maxDistance) {
                bullets.splice(i, 1);
                continue;
            }
            
            if (!bullet.canPassThroughWalls) {
                let hitWall = false;
                for (const wall of walls) {
                    if (bullet.x + bullet.size > wall.x && 
                        bullet.x - bullet.size < wall.x + wall.width &&
                        bullet.y + bullet.size > wall.y && 
                        bullet.y - bullet.size < wall.y + wall.height) {
                        
                        const bulletLeft = bullet.x - bullet.size;
                        const bulletRight = bullet.x + bullet.size;
                        const bulletTop = bullet.y - bullet.size;
                        const bulletBottom = bullet.y + bullet.size;
                        
                        const wallLeft = wall.x;
                        const wallRight = wall.x + wall.width;
                        const wallTop = wall.y;
                        const wallBottom = wall.y + wall.height;
                        
                        const overlapLeft = bulletRight - wallLeft;
                        const overlapRight = wallRight - bulletLeft;
                        const overlapTop = bulletBottom - wallTop;
                        const overlapBottom = wallBottom - bulletTop;
                        
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                        
                        if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                            bullet.angle = Math.PI - bullet.angle;
                        } else {
                            bullet.angle = -bullet.angle;
                        }
                        
                        if (minOverlap === overlapLeft) {
                            bullet.x = wallLeft - bullet.size;
                        } else if (minOverlap === overlapRight) {
                            bullet.x = wallRight + bullet.size;
                        } else if (minOverlap === overlapTop) {
                            bullet.y = wallTop - bullet.size;
                        } else {
                            bullet.y = wallBottom + bullet.size;
                        }
                        
                        // Create bullet impact effect
                        createBulletImpact(bullet.x, bullet.y, bullet.angle, bullet.weapon);
                        
                        // Add wall decal
                        wallDecals.push(new WallDecal(
                            bullet.x, 
                            bullet.y, 
                            bullet.angle + Math.PI, 
                            bullet.size * 2,
                            bullet.color
                        ));
                        
                        createParticles(bullet.x, bullet.y, '#ff00ff', 5, 2);
                        
                        bullet.bounces--;
                        if (bullet.bounces <= 0) {
                            bullets.splice(i, 1);
                        }
                        
                        hitWall = true;
                        break;
                    }
                }
                
                if (hitWall) continue;
            }
            
            if (!bullet.canPassThroughWalls) {
                for (const door of doors) {
                    if (!door.isBroken &&
                        bullet.x + bullet.size > door.x && 
                        bullet.x - bullet.size < door.x + door.width &&
                        bullet.y + bullet.size > door.y && 
                        bullet.y - bullet.size < door.y + door.height) {
                        
                        door.health--;
                        createParticles(bullet.x, bullet.y, '#ffff00', 10, 3);
                        
                        if (door.health <= 0) {
                            door.isBroken = true;
                            createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                            shakeScreen(10);
                            soundManager.play('doorBreak');
                        }
                        
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }
            
            if (!bullet.isEnemyBullet) {
                // Check collision with enemies
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check for headshot (bullet hits upper part of enemy)
                    const isHeadshot = dy < -enemy.size / 2;
                    
                    if (distance < bullet.size + enemy.size) {
                        if (enemy.type === 'shield' && enemy.hasShield) {
                            enemy.shieldHealth -= bullet.damage * player.damageMultiplier;
                            createParticles(bullet.x, bullet.y, '#0099ff', 5, 2);
                            
                            if (enemy.shieldHealth <= 0) {
                                enemy.hasShield = false;
                                createParticles(enemy.x, enemy.y, '#0099ff', 20, 5);
                                shakeScreen(5);
                            }
                            
                            bullets.splice(i, 1);
                            break;
                        }
                        
                        // Calculate damage with headshot bonus
                        let damage = bullet.damage * player.damageMultiplier;
                        if (isHeadshot) {
                            damage *= 2;
                            headshotKills++;
                        }
                        
                        enemy.health -= damage;
                        
                        // Create enemy hit effect
                        createEnemyHitEffect(enemy, damage, isHeadshot);
                        
                        if (enemy.health <= 0) {
                            if (enemy.type === 'suicide' && enemy.explodesOnDeath) {
                                createExplosion(enemy.x, enemy.y, enemy.explosionRadius, enemy.attackDamage);
                            }
                            
                            // Drop ammo
                            if (enemyTypes[enemy.type].ammoDrop && Math.random() < enemyTypes[enemy.type].ammoDrop.chance) {
                                const ammoTypeKeys = Object.keys(ammoTypes);
                                const randomAmmoType = ammoTypeKeys[Math.floor(Math.random() * ammoTypeKeys.length)];
                                ammoDrops.push(new AmmoDrop(
                                    enemy.x, 
                                    enemy.y, 
                                    randomAmmoType
                                ));
                            }
                            
                            enemies.splice(j, 1);
                            kills++;
                            
                            // Track sniper kills for achievement
                            if (bullet.weapon === 'sniper') {
                                sniperKills++;
                            }
                            
                            let points = enemyTypes[enemy.type].points;
                            const comboMultiplier = Math.min(combo, 10);
                            points *= comboMultiplier;
                            
                            // Headshot bonus
                            if (isHeadshot) {
                                points *= 1.5;
                            }
                            
                            score += points;
                            
                            // Create kill notification
                            createKillNotification(enemy.x, enemy.y, isHeadshot ? 'headshot' : 'normal');
                            
                            let comboText = combo > 1 ? ` x${combo} COMBO!` : '';
                            floatingTexts.push(new FloatingText(
                                enemy.x, 
                                enemy.y - enemy.size, 
                                `+${points}${comboText}`, 
                                combo > 1 ? '#ffff00' : '#00ff00'
                            ));
                            
                            const now = Date.now();
                            if (now - lastKillTime < 2000) {
                                combo++;
                            } else {
                                combo = 1;
                            }
                            lastKillTime = now;
                            
                            createBloodSplatter(enemy.x, enemy.y, 10);
                            shakeScreen(5);
                            soundManager.play('enemyDeath');
                            
                            updateHUD();
                            checkAchievements();
                        }
                        
                        if (!bullet.canPassThroughWalls) {
                            bullets.splice(i, 1);
                        }
                        break;
                    }
                }
                
                // Check collision with boss
                if (boss) {
                    const dx = bullet.x - boss.x;
                    const dy = bullet.y - boss.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bullet.size + boss.size) {
                        if (boss.takeDamage(bullet.damage * player.damageMultiplier)) {
                            boss = null;
                        }
                        
                        if (!bullet.canPassThroughWalls) {
                            bullets.splice(i, 1);
                        }
                    }
                }
            }
            
            if (bullet.isEnemyBullet) {
                const dx = bullet.x - player.x;
                const dy = bullet.y - player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < bullet.size + player.size) {
                    if (!player.invulnerable && !player.isDead) {
                        player.health -= bullet.damage;
                        player.invulnerable = true;
                        player.invulnerableTime = 60;
                        createBloodSplatter(player.x, player.y, 5);
                        shakeScreen(10);
                        camera.flashIntensity = 15;
                        updateHUD();
                        soundManager.play('playerHit');
                        
                        if (player.health <= 0) {
                            playerDeath();
                        }
                    }
                    
                    bullets.splice(i, 1);
                }
            }
        }
        
        // Update bullet trails
        for (let i = bulletTrails.length - 1; i >= 0; i--) {
            if (bulletTrails[i].update()) {
                bulletTrails.splice(i, 1);
            }
        }
    }
    
    function updateExplosions() {
        for (let i = explosions.length - 1; i >= 0; i--) {
            if (explosions[i].update()) {
                explosions.splice(i, 1);
            }
        }
    }
    
    function updatePowerUps() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
            if (powerUps[i].update()) {
                powerUps.splice(i, 1);
                powerUpsCollected++;
                checkAchievements();
            }
        }
    }
    
    function updateAmmoDrops() {
        for (let i = ammoDrops.length - 1; i >= 0; i--) {
            if (ammoDrops[i].update()) {
                ammoDrops.splice(i, 1);
            }
        }
    }
    
    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            
            if (p.life <= 0) {
                particles.splice(i, 1);
            }
        }
    }
    
    function updateFloatingTexts() {
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            const text = floatingTexts[i];
            text.update();
            if (text.life <= 0) {
                floatingTexts.splice(i, 1);
            }
        }
    }
    
    // ========== HELPER FUNCTIONS ==========
    function lineIntersectsRect(x1, y1, x2, y2, rectX1, rectY1, rectX2, rectY2) {
        if ((x1 >= rectX1 && x1 <= rectX2 && y1 >= rectY1 && y1 <= rectY2) ||
            (x2 >= rectX1 && x2 <= rectX2 && y2 >= rectY1 && y2 <= rectY2)) {
            return true;
        }
        
        if (lineIntersectsLine(x1, y1, x2, y2, rectX1, rectY1, rectX1, rectY2)) return true;
        if (lineIntersectsLine(x1, y1, x2, y2, rectX2, rectY1, rectX2, rectY2)) return true;
        if (lineIntersectsLine(x1, y1, x2, y2, rectX1, rectY1, rectX2, rectY1)) return true;
        if (lineIntersectsLine(x1, y1, x2, y2, rectX1, rectY2, rectX2, rectY2)) return true;
        
        return false;
    }
    
    function lineIntersectsLine(x1, y1, x2, y2, x3, y3, x4, y4) {
        const denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        if (denominator === 0) return false;
        
        const ua = (((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator);
        const ub = (((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator);
        
        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
    }
    
    function shakeScreen(intensity) {
        camera.shakeIntensity = intensity;
    }
    
    // ========== ACTION FUNCTIONS ==========
    function shootPistol() {
        // Check if player has ammo
        if (player.pistolAmmo <= 0) {
            // Out of ammo notification
            floatingTexts.push(new FloatingText(
                player.x, 
                player.y - player.size - 20, 
                'OUT OF AMMO!', 
                '#ff0000'
            ));
            return;
        }
        
        // Apply recoil
        player.recoilAngle = (Math.random() - 0.5) * 0.1;
        
        // Create muzzle flash
        createMuzzleFlash(player.x, player.y, player.angle, weaponProperties.pistol.color);
        player.muzzleFlash = 5;
        
        bullets.push({
            x: player.x,
            y: player.y,
            angle: player.angle + player.recoilAngle,
            speed: weaponProperties.pistol.bulletSpeed,
            size: 4,
            distance: 0,
            maxDistance: weaponProperties.pistol.bulletRange,
            bounces: weaponProperties.pistol.bounces,
            damage: weaponProperties.pistol.damage,
            weapon: 'pistol',
            canPassThroughWalls: false
        });
        
        // Create bullet trail
        bulletTrails.push(new BulletTrail(
            player.x, 
            player.y, 
            player.angle, 
            20, 
            weaponProperties.pistol.color, 
            10
        ));
        
        createParticles(player.x, player.y, weaponProperties.pistol.color, 5, 2);
        soundManager.play('pistol');
    }
    
    function shootShotgun() {
        // Check if player has ammo
        if (player.shotgunAmmo <= 0) {
            // Out of ammo notification
            floatingTexts.push(new FloatingText(
                player.x, 
                player.y - player.size - 20, 
                'OUT OF AMMO!', 
                '#ff0000'
            ));
            return;
        }
        
        // Apply recoil
        player.recoilAngle = (Math.random() - 0.5) * 0.2;
        
        // Create muzzle flash
        createMuzzleFlash(player.x, player.y, player.angle, weaponProperties.shotgun.color);
        player.muzzleFlash = 8;
        
        const pelletCount = weaponProperties.shotgun.pelletCount;
        const spreadAngle = weaponProperties.shotgun.spreadAngle;
        
        for (let i = 0; i < pelletCount; i++) {
            const angleOffset = (i - pelletCount/2) * spreadAngle / pelletCount;
            bullets.push({
                x: player.x,
                y: player.y,
                angle: player.angle + angleOffset + player.recoilAngle,
                speed: weaponProperties.shotgun.bulletSpeed,
                size: 3,
                distance: 0,
                maxDistance: weaponProperties.shotgun.bulletRange,
                bounces: weaponProperties.shotgun.bounces,
                damage: weaponProperties.shotgun.damage,
                weapon: 'shotgun',
                canPassThroughWalls: false
            });
            
            // Create bullet trail for each pellet
            bulletTrails.push(new BulletTrail(
                player.x, 
                player.y, 
                player.angle + angleOffset, 
                15, 
                weaponProperties.shotgun.color, 
                8
            ));
        }
        
        createParticles(player.x, player.y, weaponProperties.shotgun.color, 10, 3);
        soundManager.play('shotgun');
    }
    
    function shootSniper() {
        // Check if player has ammo
        if (player.sniperAmmo <= 0) {
            // Out of ammo notification
            floatingTexts.push(new FloatingText(
                player.x, 
                player.y - player.size - 20, 
                'OUT OF AMMO!', 
                '#ff0000'
            ));
            return;
        }
        
        // Apply recoil
        player.recoilAngle = (Math.random() - 0.5) * 0.05;
        
        // Create muzzle flash
        createMuzzleFlash(player.x, player.y, player.angle, weaponProperties.sniper.color);
        player.muzzleFlash = 10;
        
        bullets.push({
            x: player.x,
            y: player.y,
            angle: player.angle + player.recoilAngle,
            speed: weaponProperties.sniper.bulletSpeed,
            size: 6,
            distance: 0,
            maxDistance: weaponProperties.sniper.bulletRange,
            bounces: weaponProperties.sniper.bounces,
            damage: weaponProperties.sniper.damage,
            weapon: 'sniper',
            canPassThroughWalls: true
        });
        
        // Create bullet trail
        bulletTrails.push(new BulletTrail(
            player.x, 
            player.y, 
            player.angle, 
            30, 
            weaponProperties.sniper.color, 
            15
        ));
        
        createParticles(player.x, player.y, weaponProperties.sniper.color, 8, 4);
        shakeScreen(5);
        soundManager.play('sniper');
    }
    
    function meleeAttack() {
        // Create melee attack effect
        const attackDistance = 30;
        const attackX = player.x + Math.cos(player.angle) * attackDistance;
        const attackY = player.y + Math.sin(player.angle) * attackDistance;
        
        createParticles(attackX, attackY, '#ffffff', 10, 3);
        
        // Check for enemies in range
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            const dx = enemy.x - player.x;
            const dy = enemy.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < player.size + enemy.size + attackDistance) {
                // Check if enemy is in attack arc (within 45 degrees of player's facing direction)
                const angleToEnemy = Math.atan2(dy, dx);
                let angleDiff = Math.abs(angleToEnemy - player.angle);
                
                // Normalize angle difference to [0, PI]
                if (angleDiff > Math.PI) {
                    angleDiff = 2 * Math.PI - angleDiff;
                }
                
                if (angleDiff < Math.PI / 4) { // 45 degrees
                    enemy.health -= weaponProperties.melee.damage;
                    
                    // Create hit effect
                    createEnemyHitEffect(enemy, weaponProperties.melee.damage);
                    
                    // Knockback
                    const knockbackForce = 5;
                    enemy.x += Math.cos(angleToEnemy) * knockbackForce;
                    enemy.y += Math.sin(angleToEnemy) * knockbackForce;
                    
                    if (enemy.health <= 0) {
                        // Drop ammo
                        if (enemyTypes[enemy.type].ammoDrop && Math.random() < enemyTypes[enemy.type].ammoDrop.chance) {
                            const ammoTypeKeys = Object.keys(ammoTypes);
                            const randomAmmoType = ammoTypeKeys[Math.floor(Math.random() * ammoTypeKeys.length)];
                            ammoDrops.push(new AmmoDrop(
                                enemy.x, 
                                enemy.y, 
                                randomAmmoType
                            ));
                        }
                        
                        enemies.splice(i, 1);
                        kills++;
                        
                        let points = enemyTypes[enemy.type].points;
                        const comboMultiplier = Math.min(combo, 10);
                        points *= comboMultiplier;
                        
                        score += points;
                        
                        // Create kill notification
                        createKillNotification(enemy.x, enemy.y, 'melee');
                        
                        let comboText = combo > 1 ? ` x${combo} COMBO!` : '';
                        floatingTexts.push(new FloatingText(
                            enemy.x, 
                            enemy.y - enemy.size, 
                            `+${points}${comboText}`, 
                            combo > 1 ? '#ffff00' : '#00ff00'
                        ));
                        
                        const now = Date.now();
                        if (now - lastKillTime < 2000) {
                            combo++;
                        } else {
                            combo = 1;
                        }
                        lastKillTime = now;
                        
                        createBloodSplatter(enemy.x, enemy.y, 10);
                        shakeScreen(5);
                        soundManager.play('enemyDeath');
                        
                        updateHUD();
                        checkAchievements();
                    }
                }
            }
        }
    }
    
    function enemyShoot(enemy) {
        const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
        
        bullets.push({
            x: enemy.x,
            y: enemy.y,
            angle: angle,
            speed: enemy.bulletSpeed,
            size: 5,
            distance: 0,
            maxDistance: 1000,
            bounces: 0,
            damage: enemy.attackDamage,
            weapon: 'enemy',
            canPassThroughWalls: enemy.canShootThroughWalls,
            isEnemyBullet: true
        });
        
        // Create bullet trail
        bulletTrails.push(new BulletTrail(
            enemy.x, 
            enemy.y, 
            angle, 
            15, 
            '#ff0000', 
            10
        ));
        
        createParticles(enemy.x, enemy.y, '#ff0000', 5, 2);
        soundManager.play('pistol', 0.7);
    }
    
    function enemyAttack(enemy) {
        if (!player.invulnerable && !player.isDead) {
            player.health -= enemy.attackDamage;
            player.invulnerable = true;
            player.invulnerableTime = 60;
            createBloodSplatter(player.x, player.y, 5);
            shakeScreen(10);
            camera.flashIntensity = 15;
            updateHUD();
            soundManager.play('enemyHit');
            
            if (player.health <= 0) {
                playerDeath();
            }
        }
        
        createParticles(enemy.x, enemy.y, '#ff0000', 10, 4);
    }
    
    function playerDeath() {
        player.isDead = true;
        createBloodSplatter(player.x, player.y, 20);
        shakeScreen(20);
        
        // Create death explosion
        createExplosion(player.x, player.y, 100, 0);
    }
    
    function createBloodSplatter(x, y, intensity) {
        for (let i = 0; i < intensity * 5; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 50;
            const splatterX = x + Math.cos(angle) * distance;
            const splatterY = y + Math.sin(angle) * distance;
            const size = Math.random() * 10 + 5;
            
            bloodSplatters.push({
                x: splatterX,
                y: splatterY,
                size: size,
                color: `rgba(${150 + Math.random() * 50}, 0, 0, ${0.5 + Math.random() * 0.5})`
            });
        }
        
        createParticles(x, y, '#ff0000', intensity * 10, 5);
    }
    
    function createParticles(x, y, color, count, speed) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * 3 + 1,
                color: color,
                life: 30
            });
        }
    }
    
    function playerKick() {
        player.isKicking = true;
        
        const kickDistance = 50;
        const kickX = player.x + Math.cos(player.angle) * kickDistance;
        const kickY = player.y + Math.sin(player.angle) * kickDistance;
        
        createParticles(kickX, kickY, '#ffffff', 10, 3);
        
        for (const door of doors) {
            if (!door.isBroken &&
                kickX > door.x && 
                kickX < door.x + door.width &&
                kickY > door.y && 
                kickY < door.y + door.height) {
                
                door.health--;
                createParticles(door.x + door.width/2, door.y + door.height/2, '#ffff00', 15, 4);
                
                if (door.health <= 0) {
                    door.isBroken = true;
                    createParticles(door.x + door.width/2, door.y + door.height/2, '#ff9900', 30, 6);
                    shakeScreen(10);
                    soundManager.play('doorBreak');
                }
                
                break;
            }
        }
        
        setTimeout(() => {
            player.isKicking = false;
        }, 200);
    }
    
    function updateHUD() {
        const killCountElement = document.getElementById('killCount');
        const comboCountElement = document.getElementById('comboCount');
        const healthElement = document.getElementById('healthCount');
        const scoreElement = document.getElementById('scoreCount');
        
        if (killCountElement) killCountElement.textContent = kills;
        if (comboCountElement) comboCountElement.textContent = combo;
        if (healthElement) healthElement.textContent = player.health;
        if (scoreElement) scoreElement.textContent = score;
    }
    
    function resetGame() {
        kills = 0;
        combo = 0;
        score = 0;
        powerUpsCollected = 0;
        explosionKills = 0;
        statusEffectsSurvived = 0;
        doorsDestroyed = 0;
        sniperKills = 0;
        roomsCleared = 0;
        executionKills = 0;
        headshotKills = 0;
        difficultyLevel = 1;
        enemySpawnInterval = 300;
        maxEnemies = 30;
        
        player.health = player.maxHealth;
        player.pistolAmmo = weaponProperties.pistol.maxAmmo;
        player.shotgunAmmo = weaponProperties.shotgun.maxAmmo;
        player.sniperAmmo = weaponProperties.sniper.maxAmmo;
        player.isReloading = false;
        player.isShotgunCocked = true;
        player.isSniperReady = true;
        player.isDead = false;
        levelComplete = false;
        levelStartTime = Date.now();
        floatingTexts = [];
        
        // Reset power-ups
        player.speedMultiplier = 1;
        player.fireRateMultiplier = 1;
        player.damageMultiplier = 1;
        player.invulnerable = false;
        for (const effect in player.powerUpTimers) {
            player.powerUpTimers[effect] = 0;
        }
        
        // Reset status effects
        player.isFrozen = false;
        player.frozenTime = 0;
        player.isBurning = false;
        player.burnTime = 0;
        player.burnDamageTimer = 0;
        player.isShocked = false;
        player.shockedTime = 0;
        player.isHacked = false;
        player.hackedTime = 0;
        
        // Reset camera position
        camera.x = 0;
        camera.y = 0;
        
        // Reset achievements
        for (const achievement of achievements) {
            if (achievement.id !== 'bossSlayer') {
                achievement.unlocked = false;
            }
        }
        
        initLevel();
        updateHUD();
    }
    
    // ========== DRAWING FUNCTIONS ==========
    function drawWalls() {
        for (const wall of walls) {
            if (wall.x + wall.width > camera.x && 
                wall.x < camera.x + camera.width &&
                wall.y + wall.height > camera.y && 
                wall.y < camera.y + camera.height) {
                
                ctx.fillStyle = '#774400';
                ctx.fillRect(wall.x - camera.x, wall.y - camera.y, wall.width, wall.height);
                
                ctx.strokeStyle = '#553300';
                ctx.lineWidth = 1;
                
                for (let j = 0; j < wall.height; j += 15) {
                    ctx.beginPath();
                    ctx.moveTo(wall.x - camera.x, wall.y + j - camera.y);
                    ctx.lineTo(wall.x + wall.width - camera.x, wall.y + j - camera.y);
                    ctx.stroke();
                }
                
                for (let i = 0; i < wall.width; i += 30) {
                    for (let j = 0; j < wall.height; j += 30) {
                        ctx.beginPath();
                        ctx.moveTo(wall.x + i - camera.x, wall.y + j - camera.y);
                        ctx.lineTo(wall.x + i - camera.x, wall.y + j + 15 - camera.y);
                        ctx.stroke();
                    }
                }
                
                ctx.fillStyle = '#885500';
                for (let i = 0; i < 3; i++) {
                    const peelX = wall.x + Math.random() * wall.width;
                    const peelY = wall.y + Math.random() * wall.height;
                    const peelWidth = Math.random() * 20 + 10;
                    const peelHeight = Math.random() * 5 + 2;
                    
                    ctx.fillRect(peelX - camera.x, peelY - camera.y, peelWidth, peelHeight);
                }
                
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.strokeRect(wall.x - camera.x, wall.y - camera.y, wall.width, wall.height);
            }
        }
        
        // Draw wall decals
        for (const decal of wallDecals) {
            if (decal.x > camera.x && 
                decal.x < camera.x + camera.width &&
                decal.y > camera.y && 
                decal.y < camera.y + camera.height) {
                decal.draw(ctx);
            }
        }
    }
    
    function drawDoors() {
        for (const door of doors) {
            if (door.x + door.width > camera.x && 
                door.x < camera.x + camera.width &&
                door.y + door.height > camera.y && 
                door.y < camera.y + camera.height) {
                
                if (!door.isBroken) {
                    // Different color for locked doors
                    if (door.isLocked) {
                        ctx.fillStyle = '#8B0000'; // Dark red for locked doors
                    } else {
                        ctx.fillStyle = '#8B4513'; // Normal brown for unlocked doors
                    }
                    
                    ctx.fillRect(door.x - camera.x, door.y - camera.y, door.width, door.height);
                    
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 1;
                    
                    for (let i = 5; i < door.width; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(door.x + i - camera.x, door.y - camera.y);
                        ctx.lineTo(door.x + i - camera.x, door.y + door.height - camera.y);
                        ctx.stroke();
                    }
                    
                    // Different outline for locked doors
                    if (door.isLocked) {
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                    } else {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 2;
                    }
                    
                    ctx.strokeRect(door.x - camera.x, door.y - camera.y, door.width, door.height);
                    
                    if (door.health < door.maxHealth) {
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 1;
                        const crackCount = door.maxHealth - door.health;
                        
                        for (let i = 0; i < crackCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(
                                door.x + Math.random() * door.width - camera.x,
                                door.y + Math.random() * door.height - camera.y
                            );
                            ctx.lineTo(
                                door.x + Math.random() * door.width - camera.x,
                                door.y + Math.random() * door.height - camera.y
                            );
                            ctx.stroke();
                        }
                    }
                } else {
                    ctx.fillStyle = '#8B4513';
                    
                    for (let i = 0; i < 8; i++) {
                        const fragmentX = door.x + Math.random() * door.width;
                        const fragmentY = door.y + Math.random() * door.height;
                        const fragmentWidth = Math.random() * 15 + 5;
                        const fragmentHeight = Math.random() * 15 + 5;
                        
                        ctx.save();
                        ctx.translate(fragmentX - camera.x, fragmentY - camera.y);
                        ctx.rotate(Math.random() * Math.PI);
                        ctx.fillRect(-fragmentWidth/2, -fragmentHeight/2, fragmentWidth, fragmentHeight);
                        ctx.restore();
                    }
                }
            }
        }
    }
    
    function drawRooms() {
        // Draw rooms
        for (const room of rooms) {
            room.draw(ctx);
        }
    }
    
    function drawBloodSplatters() {
        for (const splatter of bloodSplatters) {
            if (splatter.x > camera.x && 
                splatter.x < camera.x + camera.width &&
                splatter.y > camera.y && 
                splatter.y < camera.y + camera.height) {
                
                ctx.fillStyle = splatter.color;
                ctx.beginPath();
                ctx.arc(splatter.x - camera.x, splatter.y - camera.y, splatter.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    function drawPlayer() {
        ctx.save();
        ctx.translate(player.x - camera.x, player.y - camera.y);
        ctx.rotate(player.angle + player.recoilAngle);
        
        // Draw player with power-up effects
        if (player.powerUpTimers.invulnerability > 0) {
            // Draw invulnerability shield
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, player.size + 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Draw status effects
        if (player.isFrozen) {
            // Draw ice effect
            ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, player.size + 8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        if (player.isBurning) {
            // Draw fire effect
            ctx.fillStyle = 'rgba(255, 85, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(0, 0, player.size + 8, 0, Math.PI * 2);
            ctx.fill();
        }
        
        if (player.isShocked) {
            // Draw electric effect
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * (player.size + 10), Math.sin(angle) * (player.size + 10));
                ctx.stroke();
            }
        }
        
        if (player.isHacked) {
            // Draw hack effect
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = player.size + 5 + Math.sin(Date.now() / 100 + i) * 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                ctx.stroke();
            }
        }
        
        // Draw player body
        ctx.fillStyle = player.invulnerable && Math.floor(player.invulnerableTime / 5) % 2 === 0 ? '#ffffff' : '#00ffff';
        ctx.beginPath();
        ctx.arc(0, 0, player.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw player weapon
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(player.size + 5, 0);
        ctx.stroke();
        
        // Draw muzzle flash
        if (player.muzzleFlash > 0) {
            const flashSize = player.muzzleFlash * 2;
            const gradient = ctx.createRadialGradient(
                player.size + 5, 0, 0,
                player.size + 5, 0, flashSize
            );
            
            if (player.currentWeapon === 'pistol') {
                gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
            } else if (player.currentWeapon === 'shotgun') {
                gradient.addColorStop(0, 'rgba(255, 150, 0, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            } else if (player.currentWeapon === 'sniper') {
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(0, 200, 255, 0)');
            } else if (player.currentWeapon === 'melee') {
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(1, 'rgba(200, 200, 200, 0)');
            }
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(player.size + 5, 0, flashSize, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Draw execution indicator
        if (player.canExecute) {
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, player.size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        if (player.isKicking) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(player.size + 5, 0);
            ctx.lineTo(player.size + 15, -5);
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    function drawBullets() {
        for (const bullet of bullets) {
            if (bullet.weapon === 'pistol') {
                ctx.fillStyle = weaponProperties.pistol.color;
            } else if (bullet.weapon === 'shotgun') {
                ctx.fillStyle = weaponProperties.shotgun.color;
            } else if (bullet.weapon === 'sniper') {
                ctx.fillStyle = weaponProperties.sniper.color;
            } else {
                ctx.fillStyle = '#ff0000';
            }
            
            ctx.beginPath();
            ctx.arc(bullet.x - camera.x, bullet.y - camera.y, bullet.size, 0, Math.PI * 2);
            ctx.fill();
            
            if (bullet.weapon === 'pistol') {
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            } else if (bullet.weapon === 'shotgun') {
                ctx.strokeStyle = 'rgba(255, 153, 0, 0.5)';
            } else if (bullet.weapon === 'sniper') {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
            } else {
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            }
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bullet.x - camera.x, bullet.y - camera.y);
            ctx.lineTo(
                bullet.x - Math.cos(bullet.angle) * 15 - camera.x,
                bullet.y - Math.sin(bullet.angle) * 15 - camera.y
            );
            ctx.stroke();
        }
        
        // Draw bullet trails
        for (const trail of bulletTrails) {
            trail.draw(ctx);
        }
    }
    
    function drawEnemies() {
        for (const enemy of enemies) {
            // Flash white when hit
            if (enemy.hitFlash > 0) {
                ctx.fillStyle = '#ffffff';
            } else if (enemy.isCloaked) {
                // Cloaked enemies are barely visible
                ctx.fillStyle = `rgba(170, 0, 255, ${0.2 + Math.sin(Date.now() / 200) * 0.1})`;
            } else {
                ctx.fillStyle = enemy.color;
            }
            
            if (enemy.type === 'basic') {
                ctx.fillRect(
                    enemy.x - enemy.size - camera.x, 
                    enemy.y - enemy.size - camera.y, 
                    enemy.size * 2, 
                    enemy.size * 2
                );
            } else if (enemy.type === 'sniper') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(-enemy.size, -enemy.size);
                ctx.lineTo(-enemy.size, enemy.size);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            } else if (enemy.type === 'heavy') {
                ctx.beginPath();
                ctx.arc(enemy.x - camera.x, enemy.y - camera.y, enemy.size, 0, Math.PI * 2);
                ctx.fill();
            } else if (enemy.type === 'shield') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = i / 6 * Math.PI * 2;
                    const x = Math.cos(angle) * enemy.size;
                    const y = Math.sin(angle) * enemy.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                if (enemy.hasShield) {
                    ctx.strokeStyle = '#0099ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.restore();
            } else if (enemy.type === 'suicide') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    const radius = i % 2 === 0 ? enemy.size : enemy.size / 2;
                    const angle = i / 10 * Math.PI * 2;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                // Draw flash if needed
                if (enemy.shouldFlash) {
                    ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(enemy.x - camera.x, enemy.y - camera.y, enemy.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (enemy.type === 'spawner') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = i / 5 * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * enemy.size;
                    const y = Math.sin(angle) * enemy.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, enemy.size / 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            } else if (enemy.type === 'hacker') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                // Draw hacker body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(-enemy.size, -enemy.size);
                ctx.lineTo(-enemy.size, enemy.size);
                ctx.closePath();
                ctx.fill();
                
                // Draw hacker mask
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(0, 0, enemy.size / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw digital effects
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const radius = enemy.size * (0.7 + Math.sin(Date.now() / 100 + i) * 0.3);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                    ctx.stroke();
                }
                
                ctx.restore();
            } else if (enemy.type === 'cloaker') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                // Draw cloaker body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(-enemy.size, -enemy.size);
                ctx.lineTo(-enemy.size, enemy.size);
                ctx.closePath();
                ctx.fill();
                
                // Draw cloaker mask
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(0, 0, enemy.size / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw cloak effect
                if (enemy.isCloaked) {
                    ctx.strokeStyle = `rgba(170, 0, 255, ${0.3 + Math.sin(Date.now() / 100) * 0.2})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, enemy.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            } else if (enemy.type === 'fire') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                // Draw fire body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = i / 8 * Math.PI * 2;
                    const radius = i % 2 === 0 ? enemy.size : enemy.size / 1.3;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw fire core
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(0, 0, enemy.size / 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            } else if (enemy.type === 'electric') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                // Draw electric body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = i / 5 * Math.PI * 2 - Math.PI / 2;
                    const x = Math.cos(angle) * enemy.size;
                    const y = Math.sin(angle) * enemy.size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw electric core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, enemy.size / 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw electric sparks
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const sparkLength = enemy.size * (0.5 + Math.random() * 0.5);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * sparkLength, Math.sin(angle) * sparkLength);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Draw health bar
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(
                enemy.x - enemy.size - camera.x, 
                enemy.y - enemy.size - 15 - camera.y, 
                enemy.size * 2, 
                5
            );
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(
                enemy.x - enemy.size - camera.x, 
                enemy.y - enemy.size - 15 - camera.y, 
                enemy.size * 2 * healthPercent, 
                5
            );
            
            // Draw execution indicator
            if (enemy.health / enemy.maxHealth <= 0.3) {
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(enemy.x - camera.x, enemy.y - camera.y, enemy.size + 8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            if (enemy.hasKnife) {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(enemy.size + 10, 0);
                ctx.stroke();
                
                ctx.restore();
            } else if (enemy.type === 'sniper' || enemy.type === 'hacker' || enemy.type === 'fire' || enemy.type === 'electric') {
                ctx.save();
                ctx.translate(enemy.x - camera.x, enemy.y - camera.y);
                ctx.rotate(enemy.angle);
                
                let weaponColor = '#00ffff';
                if (enemy.type === 'hacker') weaponColor = '#00ff88';
                else if (enemy.type === 'fire') weaponColor = '#ff5500';
                else if (enemy.type === 'electric') weaponColor = '#ffff00';
                
                ctx.strokeStyle = weaponColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(enemy.size, 0);
                ctx.lineTo(enemy.size + 20, 0);
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Draw path for debugging (optional)
            if (enemy.path && enemy.path.length > 0) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(enemy.x - camera.x, enemy.y - camera.y);
                
                for (let i = enemy.pathIndex; i < enemy.path.length; i++) {
                    const point = enemy.path[i];
                    ctx.lineTo(point.x - camera.x, point.y - camera.y);
                }
                
                ctx.stroke();
            }
        }
    }
    
    function drawExplosions() {
        for (const explosion of explosions) {
            explosion.draw(ctx);
        }
    }
    
    function drawPowerUps() {
        for (const powerUp of powerUps) {
            powerUp.draw(ctx);
        }
    }
    
    function drawAmmoDrops() {
        for (const ammoDrop of ammoDrops) {
            ammoDrop.draw(ctx);
        }
    }
    
    function drawParticles() {
        for (const p of particles) {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 30;
            ctx.beginPath();
            ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
    
    function drawFloatingTexts() {
        for (const text of floatingTexts) {
            text.draw(ctx);
        }
    }
    
    function drawHUD() {
        ctx.fillStyle = '#ffffff';
        ctx.font = '16px Courier New';
        ctx.textAlign = 'left';
        
        ctx.fillText(`Score: ${score}`, 20, canvas.height - 160);
        
        let weaponText = `Weapon: ${player.currentWeapon === 'pistol' ? 'Pistol' : player.currentWeapon === 'shotgun' ? 'Shotgun' : player.currentWeapon === 'sniper' ? 'Sniper' : 'Melee'}`;
        ctx.fillText(weaponText, 20, canvas.height - 140);
        
        if (player.currentWeapon === 'pistol') {
            let ammoText = `Ammo: ${player.pistolAmmo}/${weaponProperties.pistol.maxAmmo}`;
            if (player.isReloading) {
                ammoText += ` (Reloading...)`;
            }
            ctx.fillText(ammoText, 20, canvas.height - 120);
        } else if (player.currentWeapon === 'shotgun') {
            let ammoText = `Ammo: ${player.shotgunAmmo}/${weaponProperties.shotgun.maxAmmo}`;
            if (player.isReloading) {
                ammoText += ` (Reloading...)`;
            } else if (!player.isShotgunCocked) {
                ammoText += ` (Needs Cocking - Press C)`;
            }
            ctx.fillText(ammoText, 20, canvas.height - 120);
        } else if (player.currentWeapon === 'sniper') {
            let ammoText = `Ammo: ${player.sniperAmmo}/${weaponProperties.sniper.maxAmmo}`;
            if (player.isReloading) {
                ammoText += ` (Reloading...)`;
            } else if (!player.isSniperReady) {
                ammoText += ` (Needs Ready - Press V)`;
            }
            ctx.fillText(ammoText, 20, canvas.height - 120);
        } else if (player.currentWeapon === 'melee') {
            ctx.fillText('Ammo: Unlimited', 20, canvas.height - 120);
        }
        
        ctx.fillText(`Health: ${player.health}/${player.maxHealth}`, 20, canvas.height - 100);
        
        // Draw status effects
        let statusY = canvas.height - 80;
        if (player.isFrozen) {
            ctx.fillStyle = '#00ffff';
            ctx.fillText(`FROZEN: ${Math.ceil(player.frozenTime / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        if (player.isBurning) {
            ctx.fillStyle = '#ff5500';
            ctx.fillText(`BURNING: ${Math.ceil(player.burnTime / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        if (player.isShocked) {
            ctx.fillStyle = '#ffff00';
            ctx.fillText(`SHOCKED: ${Math.ceil(player.shockedTime / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        if (player.isHacked) {
            ctx.fillStyle = '#00ff88';
            ctx.fillText(`HACKED: ${Math.ceil(player.hackedTime / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        
        // Draw active power-ups
        if (player.powerUpTimers.speed > 0) {
            ctx.fillStyle = '#00ff00';
            ctx.fillText(`Speed Boost: ${Math.ceil(player.powerUpTimers.speed / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        if (player.powerUpTimers.rapidFire > 0) {
            ctx.fillStyle = '#ffff00';
            ctx.fillText(`Rapid Fire: ${Math.ceil(player.powerUpTimers.rapidFire / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        if (player.powerUpTimers.damage > 0) {
            ctx.fillStyle = '#ff00ff';
            ctx.fillText(`Damage Boost: ${Math.ceil(player.powerUpTimers.damage / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        if (player.powerUpTimers.invulnerability > 0) {
            ctx.fillStyle = '#00ffff';
            ctx.fillText(`Invulnerability: ${Math.ceil(player.powerUpTimers.invulnerability / 60)}s`, 20, statusY);
            statusY -= 20;
        }
        
        ctx.fillText('1: Pistol  2: Shotgun  3: Sniper  4: Melee', 20, canvas.height - 40);
        ctx.fillText('F: Kick doors  R: Reload', 20, canvas.height - 20);
        ctx.fillText('C: Cock shotgun  V: Ready sniper', 20, canvas.height);
        ctx.fillText('WASD: Move  Mouse: Aim & Shoot', 20, canvas.height + 20);
        
        ctx.textAlign = 'right';
        ctx.fillStyle = enemyTypes.basic.color;
        ctx.fillText('Basic Enemy (10 HP)', canvas.width - 20, canvas.height - 200);
        ctx.fillStyle = enemyTypes.sniper.color;
        ctx.fillText('Sniper Enemy (25 HP)', canvas.width - 20, canvas.height - 180);
        ctx.fillStyle = enemyTypes.heavy.color;
        ctx.fillText('Heavy Enemy (40 HP)', canvas.width - 20, canvas.height - 160);
        ctx.fillStyle = enemyTypes.shield.color;
        ctx.fillText('Shield Enemy (30 HP)', canvas.width - 20, canvas.height - 140);
        ctx.fillStyle = enemyTypes.suicide.color;
        ctx.fillText('Suicide Enemy (15 HP)', canvas.width - 20, canvas.height - 120);
        ctx.fillStyle = enemyTypes.spawner.color;
        ctx.fillText('Spawner Enemy (50 HP)', canvas.width - 20, canvas.height - 100);
        ctx.fillStyle = enemyTypes.hacker.color;
        ctx.fillText('Hacker Enemy (20 HP)', canvas.width - 20, canvas.height - 80);
        ctx.fillStyle = enemyTypes.cloaker.color;
        ctx.fillText('Cloaker Enemy (15 HP)', canvas.width - 20, canvas.height - 60);
        ctx.fillStyle = enemyTypes.fire.color;
        ctx.fillText('Fire Enemy (30 HP)', canvas.width - 20, canvas.height - 40);
        ctx.fillStyle = enemyTypes.electric.color;
        ctx.fillText('Electric Enemy (25 HP)', canvas.width - 20, canvas.height - 20);
        
        ctx.fillStyle = '#ffffff';
        ctx.fillText(`Kills: ${kills}`, canvas.width - 20, canvas.height);
        ctx.fillText(`Combo: ${combo}`, canvas.width - 20, canvas.height - 5);
        ctx.fillText(`Difficulty: ${difficultyLevel}`, canvas.width - 20, canvas.height - 10);
        ctx.fillText(`Rooms Cleared: ${roomsCleared}`, canvas.width - 20, canvas.height - 15);
        ctx.fillText(`Sound: ${soundManager.enabled ? 'ON' : 'OFF'} (M to toggle)`, canvas.width - 20, canvas.height - 240);
        ctx.fillText('Achievements (TAB)', canvas.width - 20, canvas.height - 220);
        
        // Draw execution prompt
        if (player.canExecute) {
            ctx.fillStyle = '#ff0000';
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('EXECUTE! (CLICK)', canvas.width / 2, canvas.height / 2 + 50);
        }
    }
    
    function drawAchievementNotification() {
        if (showAchievement) {
            const alpha = Math.min(1, achievementTimer / 60);
            
            ctx.fillStyle = `rgba(0, 0, 0, ${0.7 * alpha})`;
            ctx.fillRect(canvas.width / 2 - 200, 100, 400, 80);
            
            ctx.strokeStyle = `rgba(255, 215, 0, ${alpha})`;
            ctx.lineWidth = 2;
            ctx.strokeRect(canvas.width / 2 - 200, 100, 400, 80);
            
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.font = 'bold 20px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('ACHIEVEMENT UNLOCKED!', canvas.width / 2, 130);
            
            ctx.font = '16px Courier New';
            ctx.fillText(showAchievement.name, canvas.width / 2, 155);
            
            ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
            ctx.font = '24px Courier New';
            ctx.fillText('üèÜ', canvas.width / 2 - 180, 140);
        }
    }
    
    function drawAchievementsScreen() {
        if (keys['tab']) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 32px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('ACHIEVEMENTS', canvas.width / 2, 50);
            
            ctx.font = '20px Courier New';
            ctx.textAlign = 'left';
            
            let y = 120;
            for (const achievement of achievements) {
                if (achievement.unlocked) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(`‚úì ${achievement.name}`, 200, y);
                } else {
                    ctx.fillStyle = '#888888';
                    ctx.fillText(`? ${achievement.name}`, 200, y);
                }
                
                ctx.fillStyle = '#cccccc';
                ctx.font = '16px Courier New';
                ctx.fillText(achievement.description, 220, y + 25);
                
                y += 70;
                ctx.font = '20px Courier New';
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.fillText('Press TAB to close', canvas.width / 2, canvas.height - 50);
        }
    }
    
    function drawScreenEffects() {
        // Draw screen flash
        if (camera.flashIntensity > 0) {
            const alpha = camera.flashIntensity / 30;
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Draw glitch effect
        if (camera.glitchIntensity > 0) {
            const alpha = camera.glitchIntensity / 30;
            
            // Create glitch blocks
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const width = Math.random() * 100 + 50;
                const height = Math.random() * 10 + 5;
                
                ctx.fillStyle = `rgba(0, 255, 136, ${alpha * 0.3})`;
                ctx.fillRect(x, y, width, height);
            }
            
            // Create scan lines
            ctx.strokeStyle = `rgba(0, 255, 136, ${alpha * 0.5})`;
            ctx.lineWidth = 1;
            
            for (let y = 0; y < canvas.height; y += 3) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Draw chromatic aberration
        if (camera.chromaticAberration > 0) {
            const intensity = camera.chromaticAberration / 10;
            
            // Red channel offset
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = `rgba(255, 0, 0, ${intensity * 0.1})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Blue channel offset
            ctx.fillStyle = `rgba(0, 0, 255, ${intensity * 0.1})`;
            ctx.fillRect(intensity * 5, 0, canvas.width, canvas.height);
            
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // Draw VHS lines
        if (camera.vhsLines) {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            
            for (let y = 0; y < canvas.height; y += 2) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Add noise
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.2})`;
                ctx.fillRect(x, y, size, size);
            }
        }
    }
    
    // ========== MAIN GAME LOOP ==========
    // ========== MAIN GAME LOOP ==========
function gameLoop() {
    // Clear canvas with trail effect
    ctx.fillStyle = 'rgba(10, 10, 10, 0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    
    if (camera.shakeIntensity > 0) {
        ctx.translate(
            (Math.random() - 0.5) * camera.shakeIntensity,
            (Math.random() - 0.5) * camera.shakeIntensity
        );
        camera.shakeIntensity *= 0.9;
    }
    
    updatePlayer();
    updateCamera();
    updateEnemies();
    updateEnemySpawning();
    updateBullets();
    updateExplosions();
    updatePowerUps();
    updateAmmoDrops();
    updateParticles();
    updateFloatingTexts();
    
    if (exitPortal) {
        exitPortal.update();
        if (exitPortal.checkCollision(player) && enemies.length === 0 && !boss) {
            levelComplete = true;
            soundManager.play('portal');
        }
    }
    
    if (boss) {
        boss.update();
    }
    
    if (showAchievement) {
        achievementTimer--;
        if (achievementTimer <= 0) {
            showAchievement = null;
        }
    }
    
    checkAchievements();
    
    drawBloodSplatters();
    drawWalls();
    drawDoors();
    drawPowerUps();
    drawEnemies();
    drawPlayer();
    drawBullets();
    drawExplosions();
    drawParticles();
    drawFloatingTexts();
    
    if (exitPortal) {
        exitPortal.draw(ctx);
    }
    
    if (boss) {
        boss.draw(ctx);
    }
    
    miniMap.draw(ctx);
    drawHUD();
    drawAchievementNotification();
    drawAchievementsScreen();
    drawScreenEffects(); // Fixed: was calling drawScreenFlash
    
    ctx.restore();
    
    if (levelComplete) {
        ctx.fillStyle = '#00ff00';
        ctx.font = '48px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL COMPLETE!', canvas.width/2, canvas.height/2);
        ctx.font = '24px Courier New';
        ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 50);
        ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 100);
        
        if (keys['r']) {
            resetGame();
        }
    }
    
    if (player.isDead) {
        ctx.fillStyle = '#ff0000';
        ctx.font = '48px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2);
        ctx.font = '24px Courier New';
        ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 50);
        
        if (keys['r']) {
            resetGame();
        }
    }
    
    requestAnimationFrame(gameLoop);
}
    
    // ========== START THE GAME ==========
    initLevel();
    loadSounds();
    updateHUD();
    gameLoop();
});